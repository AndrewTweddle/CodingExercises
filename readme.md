# Overview

This project contains my solutions to various coding exercises.

I use these to:
* practise coding skills,
* learn new programming languages,
* compare languages or paradigms,
* prepare for technical interviews, and (last but **not** least)
* have fun solving coding puzzles!

## Links within this page

| Link                                                                            | Source                                                      | Description                                  |
|---------------------------------------------------------------------------------|-------------------------------------------------------------|----------------------------------------------|
| [Project Euler](#project-euler-problems)                                        | [projecteuler.net](https://projecteuler.net)                | Coding challenges with a mathematical theme  |
| [Advent of Code](#advent-of-code) ([2020](#2020), [2021](#2021), [2022](#2022)) | [adventofcode.com](https://adventofcode.com/)               | 25 days of coding challenges run in December |
| [cryptopals](#cryptopals-crypto-challenges)                                     | [cryptopals.com](https://cryptopals.com/)                   | Cryptography challenges                      |
| [CSES Problem Set](#cses-problem-set)                                           | [cses.fi/problemset/list](https://cses.fi/problemset/list/) | Competitive coding exercises                 |
| [CodingDojo Katas](#katas-from-codingdojoorg)                                   | [CodingDojo.org](https://codingdojo.org/)                   |                                              |
| [Miscellaneous](#miscellaneous)                                                 | Miscellaneous sources                                       |                                              |
| [CTCI Exercises](#ctci)                                                         | The book "Cracking the Coding Interview"                    | Technical interview questions                |

## Related repositories

| Repository                                                                    | Description                                                                                           |
|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|
| [AndrewTweddle/GoogleCodeJam](https://github.com/AndrewTweddle/GoogleCodeJam) | Submissions to the Google CodeJam algorithmic coding competition                                      |
| [AndrewTweddle/CodeForces](https://github.com/AndrewTweddle/CodeForces)       | My entries to various [CodeForces](https://codeforces.com/) algorithmic coding contests               |
| [AndrewTweddle/fpinscala](https://github.com/AndrewTweddle/fpinscala)         | Forked exercises from the book ["Functional Programming in Scala"](http://www.manning.com/bjarnason/) |

# The exercises

## Project Euler problems

Project Euler requests that solutions not be shared online for problems beyond #100.

| #  | Description                                                                  | Date       | Solution                                                             | Notes                                                                                                                                                                                                                                       |
|----|------------------------------------------------------------------------------|------------|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | [Multiples of 3 and 5](https://projecteuler.net/problem=1)                   | 2021-04-11 | [Rust](project_euler/src/bin/problem1.rs)                            |                                                                                                                                                                                                                                             |
| 2  | [Even Fibonacci Numbers](https://projecteuler.net/problem=2)                 | 2021-04-12 | [Rust](project_euler/src/bin/problem2.rs)                            |                                                                                                                                                                                                                                             |
| 3  | [Largest Prime Factor](https://projecteuler.net/problem=3)                   | 2021-04-12 | [Rust](project_euler/src/bin/problem3.rs)                            | Experimented with, and timed, various methods of calculating primes.                                                                                                                                                                        |
| 4  | [Largest Palindrome Product](https://projecteuler.net/problem=4)             | 2021-04-12 | [Rust](project_euler/src/bin/problem4.rs)                            |                                                                                                                                                                                                                                             |
| 5  | [Smallest Multiple](https://projecteuler.net/problem=5)                      | 2021-04-12 | [Rust](project_euler/src/bin/problem5.rs)                            | Calculate lcm of 2 to 20 using gcd and reduce.                                                                                                                                                                                              |
|    |                                                                              | 2021-04-12 | [Rust](project_euler/src/bin/problem5_v2.rs)                         | Calculate lcm of 2 to 20 using primes.                                                                                                                                                                                                      |
| 6  | [Sum square difference](https://projecteuler.net/problem=6)                  | 2021-04-12 | [Rust](project_euler/src/bin/problem6.rs)                            | Very short and creative solution: sum of squares - square of sums = sum of squares - sum of cubes.                                                                                                                                          |
| 7  | [10001st prime](https://projecteuler.net/problem=7)                          | 2021-04-13 | [Rust](project_euler/src/bin/problem7.rs)                            |                                                                                                                                                                                                                                             |
| 8  | [Largest product in a series](https://projecteuler.net/problem=8)            | 2021-04-13 | [Rust](project_euler/src/bin/problem8.rs)                            |                                                                                                                                                                                                                                             |
| 9  | [Special Pythagorean triplet](https://projecteuler.net/problem=9)            | 2021-04-14 | [Rust](project_euler/src/bin/problem9.rs)                            |                                                                                                                                                                                                                                             |
| 10 | [Summation of primes](https://projecteuler.net/problem=10)                   | 2021-04-15 | [Rust](project_euler/src/bin/problem10.rs)                           | Includes performance comparison of getting primes using 3 variants on the Sieve of Eratosthenes (see [Wikipedia](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_and_variants)).                                              |
| 11 | [Largest product in a grid](https://projecteuler.net/problem=11)             | 2021-04-16 | [Rust](project_euler/src/bin/problem11.rs)                           |                                                                                                                                                                                                                                             |
| 12 | [Highly divisible triangular number](https://projecteuler.net/problem=12)    | 2021-04-17 | [Rust](project_euler/src/bin/problem12.rs)                           | Duration: 182.176 ms. Original attempt. Succinct but slow, because `i*i <= n` is performed repeatedly in the innermost loop.                                                                                                                |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_sqrt_bounds_binary_search.rs) | Duration: 133.348 ms. Do binary search for integer square root based on lower and upper integer bounds. Still slow, even though int sqrt is outside the inner loop.                                                                         |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_rel_prime_divisors.rs)        | Duration: 2.400 ms. I had a brainwave! T(n) = n*(n+1)/2. n and n+1 are relatively prime. Hence # of divisors of T(n) is the product of # of divisors of n/2 and n+1 (if n is even) or n and (n+1)/2 if odd.                                 |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_prime_factors.rs)             | Duration: 1.540 ms. As above, but also pre-generate a few primes and further decompose each divisor by these primes before counting the # of divisors. 30 makes a good cut-off, so factorize up to 29.                                      |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_const_prime_factors.rs)       | Duration: 853 µs. As above, but hard-coding the primes up to 31, instead of calculating them on the fly.                                                                                                                                    |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_primes_6q_plus_r.rs)          | Duration: 734 µs. As above, but only count divisors of the remainder (after reducing by primes up to 31) of the form 6q+1 or 6q+5.                                                                                                          |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_primes_30q_plus_r.rs)         | Duration: 845 µs. As above, but only count divisors of the remainder (after reducing by small primes) of the form 30q+r for suitable r. This is slower for n=500, but scales well for much higher values.                                   |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_const_prime_factors_mpsc.rs)  | Duration: 5.598 ms. Using hard-coded primes, with mpsc (5 threads works well on my PC). Perhaps unsurprisingly, this is much slower since we are not I/O bound. It catches up for very large n (> 10,000).                                  |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_repeated_factorization.rs)    | Duration: 1.735 ms. Instead of pre-computing or hard-coding primes, completely factorize into primes on the fly. Although slower, this solution is shorter and more elegant.                                                                |
| 13 | [Large sum](https://projecteuler.net/problem=13)                             | 2021-04-17 | [Rust](project_euler/src/bin/problem13.rs)                           |                                                                                                                                                                                                                                             |
| 14 | [Longest Collatz sequence](https://projecteuler.net/problem=14)              | 2021-04-19 | [Rust](project_euler/src/bin/problem14.rs)                           |                                                                                                                                                                                                                                             |
| 15 | [Lattice paths](https://projecteuler.net/problem=15)                         | 2021-04-30 | [Rust](project_euler/src/bin/problem15.rs)                           | Duration: 13.4 µs. Calculate combinatorial without overflow by aggressively cancelling common factors from numerators & denominators.                                                                                                       |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem15_diagonal_sweep.rs)            | Duration: 18.7 µs. Calculate paths from top left to bottom right by doing a "diagonal sweep", calculating distances to each point on a diagonal based on the previous diagonal.                                                             |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem15_fast_combinatorial.rs)        | Duration: 11.3 µs. I converted someone else's C++ solution to Rust. Calculate a combinatorial by generating and iterating through all relevant primes and calculating its contribution to each factorial.                                   |
| 16 | [Power digit sum](https://projecteuler.net/problem=16)                       | 2021-05-02 | [Rust](project_euler/src/bin/problem16.rs)                           | Duration: 13.1 µs. Problem: Sum the decimal digits in 2^1000. Solution: Use base 10^19 < 2^64. Store digits as u128. So squaring a digit and adding a carry will not overflow. 2^1000 = ((((2^125)^2)^2)^2.                                 |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem16_decimal_digits.rs)            | Duration: 951.9 µs. By contrast, calculating one decimal digit at a time is very slow, showing how neat the previous solution is! However, it is much simpler and shorter to do one decimal digit at a time.                                |
|    |                                                                              | 2021-05-03 | [Rust](project_euler/src/bin/problem16_bigint.rs)                    | Duration: 5.3 µs. Using the num-bigint crate.                                                                                                                                                                                               |
|    |                                                                              | 2021-05-04 | [Rust](project_euler/src/bin/problem16_bigint_fast.rs)               | Duration: 4.9 µs. Using the num-bigint crate and calculating digits by dividing by 10 and taking remainders, not by converting to a string and iterating over chars.                                                                        |
|    |                                                                              | 2021-05-10 | [Rust](project_euler/src/bin/problem16_rayon.rs)                     | Duration: 45.8 µs. Using the original approach, but summing the digits in parallel using the rayon crate (as a way of learning rayon). This was MUCH slower.                                                                                |
|    |                                                                              | 2021-05-10 | [Rust](project_euler/src/bin/problem16_original_fast.rs)             | Duration: 10.767 µs. Using the original approach again, but calculating the digits by dividing by 10 and taking remainders.                                                                                                                 |
| 17 | [Number Letter Counts](https://projecteuler.net/problem=17)                  | 2021-05-20 | [Rust](project_euler/src/bin/problem17_tdd_collab.rs)                | Duration: 373 µs. TDD solution pair programmed with a colleague (for him to show me how he does TDD, and for me to show him Rust). proptest crate also used for property-based testing of the algorithm.                                    |
|    |                                                                              | 2021-05-20 | [Rust](project_euler/src/bin/problem17.rs)                           | Duration: 9 ns. Coded on my own using a more intuitive approach. This was simple, succinct and lightning fast, but also brittle and tricky to get right.                                                                                    |
| 18 | [Maximum path sum I](https://projecteuler.net/problem=18)                    | 2021-05-31 | [Rust](project_euler/src/bin/problem18.rs)                           | Duration: 1.228 µs.                                                                                                                                                                                                                         |
|    |                                                                              | 2021-05-31 | [Rust](project_euler/src/bin/problem18_combinators.rs)               | Duration: 1.915 µs. Same algorithm, but using combinators instead of manual loops.                                                                                                                                                          |
| 19 | [Counting Sundays](https://projecteuler.net/problem=19)                      | 2021-06-01 | [Rust](project_euler/src/bin/problem19.rs)                           |                                                                                                                                                                                                                                             |
| 20 | [Factorial digit sum](https://projecteuler.net/problem=20)                   | 2021-06-06 | [Rust](project_euler/src/bin/problem20.rs)                           | Duration: 15.009 µs. Problem: Sum of digits in 100! Solution: Calculate factorial using a vector representing digits in base 10^36, since 100*(10^36-1)+max_carry_digit will not overflow a u128.                                           |
|    |                                                                              | 2021-06-06 | [Rust](project_euler/src/bin/problem20_prime_factors.rs)             | Duration: 18.875 µs. Determine factorial from prime factors, one prime at a time. Since n/p numbers in n! have p as a factor, n/(p^2) have another factor p, etc. Use base 10^19 to avoid overflowing a u128.                               |
|    |                                                                              | 2022-01-03 | [Rust](project_euler/src/bin/problem20_bigint.rs)                    | Duration: 3.221 µs. Using the num-bigint crate.                                                                                                                                                                                             |
| 21 | [Amicable numbers](https://projecteuler.net/problem=21)                      | 2021-07-04 | [Rust](project_euler/src/bin/problem21.rs)                           | Duration: 419 µs. Two similar solutions are provided. The one using a lookup table is about 6000 times faster.                                                                                                                              |
|    |                                                                              | 2021-07-04 | [Rust](project_euler/src/bin/problem21_using_primes.rs)              | Duration: 74.145 ms. Uses primes. Suppose n has prime factorization p1^e1 * p2^e2 * ... * pk^ek. then the sum of divisors of n is (1+p1+p1^2+...+p1^e1) * (1+p2+p2^2+...+p2^e2) * ... * (1+pk+pk^2+...+pk^ek).                              |
| 22 | [Names scores](https://projecteuler.net/problem=22)                          | 2021-07-17 | [Rust](project_euler/src/bin/problem22.rs)                           |                                                                                                                                                                                                                                             |
| 23 | [Non-abundant sums](https://projecteuler.net/problem=23)                     | 2021-08-23 | [Rust](project_euler/src/bin/problem23.rs)                           | Duration: 1.176 s. Simple but slow approach.                                                                                                                                                                                                |
|    |                                                                              | 2021-08-23 | [Rust](project_euler/src/bin/problem23_sum_abund_pairs.rs)           | Duration: 27 ms. More verbose, but MUCH faster!                                                                                                                                                                                             |
| 24 | [Lexicographic permutations](https://projecteuler.net/problem=24)            | 2021-08-23 | [Rust](project_euler/src/bin/problem24.rs)                           | Duration: 385 ns.                                                                                                                                                                                                                           |
|    |                                                                              | 2021-08-23 | [Rust](project_euler/src/bin/problem24_mixed_radix.rs)               | Duration: 343 ns. Flash of inspiration here! The millionth lexicographic sort of the 10 decimal digits is simply 999,999 expressed in the [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system)!                 |
| 25 | [1000-digit Fibonacci number](https://projecteuler.net/problem=25)           | 2021-09-25 | [Rust](project_euler/src/bin/problem25.rs)                           |                                                                                                                                                                                                                                             |
| 26 | [Reciprocal cycles](https://projecteuler.net/problem=26)                     | 2021-10-19 | [Rust](project_euler/src/bin/problem26.rs)                           | Duration: 1.377 ms.                                                                                                                                                                                                                         |
|    |                                                                              | 2021-10-20 | [Rust](project_euler/src/bin/problem26_fast.rs)                      | Duration: 966 µs.                                                                                                                                                                                                                           |
| 27 | [Quadratic primes](https://projecteuler.net/problem=27)                      | 2021-11-14 | [Rust](project_euler/src/bin/problem27.rs)                           |                                                                                                                                                                                                                                             |
| 28 | [Number spiral diagonals](https://projecteuler.net/problem=28)               | 2021-11-17 | [Rust](project_euler/src/bin/problem28.rs)                           |                                                                                                                                                                                                                                             |
| 29 | [Distinct powers](https://projecteuler.net/problem=29)                       | 2021-11-17 | [Rust](project_euler/src/bin/problem29.rs)                           | Duration: 2.70 ms. Problem: count distinct a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100. Solution: Generate prime representation of a's, multiply exponents by each b. Add to a set to eliminate duplicates.                                         |
|    |                                                                              | 2021-11-17 | [Rust](project_euler/src/bin/problem29_bruteforce.rs)                | Duration: 2.47 ms. Alternate solution: Represent a's as a Vec<u128> of digits in base 2^120 (so that a u128 digit doesn't overflow if multiplied by 100 or any smaller value of a). Add to a set to eliminate duplicates.                   |
|    |                                                                              | 2022-01-03 | [Rust](project_euler/src/bin/problem29_bigint.rs)                    | Duration: 2.62 ms. Using the num-bigint crate.                                                                                                                                                                                              |
| 30 | [Digit fifth powers](https://projecteuler.net/problem=30)                    | 2022-01-06 | [Rust](project_euler/src/bin/problem30.rs)                           | Duration: 8.9 ms.                                                                                                                                                                                                                           |
| 31 | [Coin sums](https://projecteuler.net/problem=31)                             | 2022-03-22 | [Rust](project_euler/src/bin/problem31.rs)                           | Duration: 14 µs.                                                                                                                                                                                                                            |
| 32 | [Pandigital products](https://projecteuler.net/problem=32)                   | 2022-03-23 | [Rust](project_euler/src/bin/problem32.rs)                           | Duration: 28 ms.                                                                                                                                                                                                                            |
| 33 | [Digit cancelling fractions](https://projecteuler.net/problem=33)            | 2022-03-24 | [Rust](project_euler/src/bin/problem33.rs)                           | Duration: 286 µs.                                                                                                                                                                                                                           |
| 34 | [Digit factorials](https://projecteuler.net/problem=34)                      | 2022-05-28 | [Rust](project_euler/src/bin/problem34.rs)                           | Duration: 9.1 ms.                                                                                                                                                                                                                           |
| 35 | [Circular primes](https://projecteuler.net/problem=35)                       | 2022-06-05 | [Rust](project_euler/src/bin/problem35.rs)                           | Duration: 10.0 ms.                                                                                                                                                                                                                          |
| 36 | [Double-base palindromes](https://projecteuler.net/problem=36)               | 2022-07-13 | [Rust](project_euler/src/bin/problem36.rs)                           | Duration: 107.5 ms. Using string comparisons.                                                                                                                                                                                               |
|    |                                                                              | 2022-07-13 | [Rust](project_euler/src/bin/problem36_fast.rs)                      | Duration: 6.1 ms. Much faster! (But almost double the code.) - No string conversions. Check reversal of bits (fast) then check decimal digits for a palindrome.                                                                             |
|    |                                                                              | 2022-07-13 | [Rust](project_euler/src/bin/problem36_loop_over_3_digits.rs)        | Duration: 13 µs. A beautiful solution and way, way faster! Use 3 nested loops over the 3 lowest digits of the decimal palindrome, generating decimal palindromes between 1 and 6 digits long. Test if each is a binary palindrome.          |
|    |                                                                              | 2022-08-10 | [Rust](project_euler/src/bin/problem36_recurse_over_digits.rs)       | Duration: 16.1 µs. Generalize the previous algorithm to work for any value of n, not just 1 million.                                                                                                                                        |
| 37 | [Truncatable primes](https://projecteuler.net/problem=37)                    | 2022-08-19 | [Rust](project_euler/src/bin/problem37.rs)                           | Duration: 94 µs. Crude approach for testing primality: See if number is of the form 6n +/- 1. If so, only check factors of the form 6k +/- 1. Reason: all primes except 2 and 3 are of the form 6n-1 or 6n+1.                               |
|    |                                                                              | 2022-08-21 | [Rust](project_euler/src/bin/problem37_cache_primes.rs)              | DO NOT RUN! Instructive only! This runs indefinitely and uses LOTS of memory! As above, but this tests for primality by caching primes up to some number. If this number is exceeded, the cache is recalculated to a higher limit.          |
| 38 | [Pandigital multiples](https://projecteuler.net/problem=38)                  | 2022-09-07 | [Rust](project_euler/src/bin/problem38.rs)                           | Duration: 137 µs. Efficient but not particularly clever, mathematically. But creating an iterator over the digits of a number was a nice touch.                                                                                             |
| 39 | [Integer right triangles](https://projecteuler.net/problem=39)               | 2022-09-11 | [Rust](project_euler/src/bin/problem39.rs)                           | Duration: 57 ms. A brute force approach: quick to write, but quite slow to run.                                                                                                                                                             |
|    |                                                                              | 2022-09-17 | [Rust](project_euler/src/bin/problem39_v2.rs)                        | Duration: 3 µs. Using [the formula for generating Pythagorean triples](https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple) and iterating over possible values of m,n,k to generate valid perimeters.                      |
|    |                                                                              | 2022-09-18 | [Rust](project_euler/src/bin/problem39_v3.rs)                        | Duration: 480 µs. Using [the formula for generating Pythagorean triples](https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple) and factorizing the perimeter to count valid combinations of m,n and k.                      |
| 40 | [Champernowne's constant](https://projecteuler.net/problem=40)               | 2023-04-12 | [Rust](project_euler/src/bin/problem40.rs)                           | Duration: 48 ns (excluding writing to console).                                                                                                                                                                                             |
| 41 | [Pandigital prime](https://projecteuler.net/problem=41)                      | 2023-05-14 | [Rust](project_euler/src/bin/problem41.rs)                           | Duration: 5.7 µs (excluding writing to console). Used the [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system) to implement a descending iterator over pandigital numbers.                                      |
| 42 | [Coded triangle numbers](https://projecteuler.net/problem=42)                | 2023-05-21 | [Rust](project_euler/src/bin/problem42.rs)                           | Using 8 T(n) + 1 = (2n+1)^2, where T(n) is the triangular number formula, along with an integer square root (floor of the sqrt) [algorithm](https://en.wikipedia.org/wiki/Integer_square_root#Using_bitwise_operations).                    |
| 43 | [Sub-string divisibility](https://projecteuler.net/problem=43)               | 2023-05-22 | [Rust](project_euler/src/bin/problem43.rs)                           | Duration: 706 ms (excluding writing to console). The [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system) was used to implement a `TenDigitPandigitalIter` (double-ended for unit testing purposes).            |
| 44 | [Pentagon Numbers](https://projecteuler.net/problem=44)                      | 2023-06-03 | [Rust](project_euler/src/bin/problem44.rs)                           | Duration: 150 s. An EXTREMELY slow solution, doing a brute force search (first over the difference, then over the smaller of the two pentagonal numbers).                                                                                   |
|    |                                                                              | 2023-06-11 | [Rust](project_euler/src/bin/problem44_v2.rs)                        | Duration: 26 s. Same algorithm, but using num crate's integer square root implementation instead of my own.                                                                                                                                 |
| 45 | [Triangular, Pentagonal, and Hexagonal](https://projecteuler.net/problem=45) | 2023-07-08 | [Rust](project_euler/src/bin/problem45.rs)                           | Duration: 71 µs (excluding writing to console). Three iterators were used, one for each value of n. The 3 iterators were moved ahead in unison to keep the 3 numbers (triangular, pentagonal and hexagonal) close together to find a match. |
|    |                                                                              | 2023-07-08 | [Rust](project_euler/src/bin/problem45_invert.rs)                    | Duration: 520 µs (excluding writing to console). Iterate over hexagonal numbers, using a formula to invert the pentagonal and triangular numbers. Slightly more succinct, but much slower than the previous solution.                       |
|    |                                                                              | 2023-07-08 | [Rust](project_euler/src/bin/problem45_fast.rs)                      | Duration: 42 µs (excluding writing to console). The same as my first solution, but using the fact that H(n) = T(2n-1), so the triangular numbers don't need to be iterated over. I had missed this, but it was pointed out on the forum.    |
| 46 | [Goldbach's Other Conjecture](https://projecteuler.net/problem=46)           | 2023-07-11 | [Rust](project_euler/src/bin/problem46.rs)                           | Duration: 2.69 ms (excluding writing to console). Cache odd primes while finding odd composites. Iterate over cached primes to check the conjecture.                                                                                        |
|    |                                                                              | 2023-07-11 | [Rust](project_euler/src/bin/problem46_v2.rs)                        | Duration: 1.81 ms (excluding writing to console). As above, but with a high performance prime testing algorithm, only testing integers (beyond 3) of the form 6k +/- 1.                                                                     |
|    |                                                                              | 2023-07-12 | [Rust](project_euler/src/bin/problem46_v3.rs)                        | Duration: 830 µs (excluding writing to console). As above, but with a better is_square() algorithm, excluding numbers whose final digits in base 16 are 0, 1, 4 or 9. (Other bases were tried, but this performed best.)                    |
|    |                                                                              | 2023-07-13 | [Rust](project_euler/src/bin/problem46_v4.rs)                        | Duration: 5.71 ms (excluding writing to console). As above, but not caching primes, and instead checking primality on the fly while checking the conjecture. This was significantly slower.                                                 |
|    |                                                                              | 2023-07-13 | [Rust](project_euler/src/bin/problem46_v5.rs)                        | Duration: 265 µs (excluding writing to console). Iterate over squares of integers, checking for a number being prime while checking the conjecture. Instead of over primes and checking for a square. Not my idea: I saw this on the forum. |
| 47 | [Distinct Primes Factors](https://projecteuler.net/problem=47)               | 2023-07-16 | [Rust](project_euler/src/bin/problem47.rs)                           | Duration: 2.3 s (excluding writing to console). Slow brute force approach. Update cache of primes when calculating only 1 divisor while iterating over integers and counting their unique prime factors.                                    |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v2.rs)                        | Duration: 0.4 s (excluding writing to console). Same algorithm. Improved speed by stopping iterating over primes when a number is fully factorized.                                                                                         |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v3.rs)                        | Duration: 1.23 s (excluding writing to console). Similar, but without caching primes. As with problem 46, this is slower than caching primes.                                                                                               |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v4.rs)                        | Duration: 212 ms (excluding writing to console). Caching primes and cache unique prime factors, so that we only need to find the first prime that divides a number. NB: This was not my idea, but something I saw on the forum.             |
| 48 | [Self Powers](https://projecteuler.net/problem=48)                           | 2023-07-24 | [Rust](project_euler/src/bin/problem48.rs)                           | Duration: 3.012 ms (excluding writing to console).                                                                                                                                                                                          |


_Note: Timings based on an i7-6700 CPU. Durations usually exclude I/O (writing the answer to the terminal) unless indicated._

## Advent of Code

### Learning by comparison

Many participants share their solutions on the reddit [AOC mega-thread](https://www.reddit.com/r/adventofcode/wiki/solution_megathreads).

This can be very useful for:
* Comparing solution approaches.
* Learning clever tricks and handy features of the language and libraries.
* Comparing readability of different coding styles and languages.
* Comparing performance of solutions.

### 2020

| Day                                          | Part | Date Solved | My solution                                           |
|----------------------------------------------|------|-------------|-------------------------------------------------------|
| [Day 1](https://adventofcode.com/2020/day/1) | 1    | 2021-11-18  | [Rust](AdventOfCode/Aoc2020/src/bin/day1_problem1.rs) | 
|                                              | 2    | 2021-11-18  | [Rust](AdventOfCode/Aoc2020/src/bin/day1_problem2.rs) |
| [Day 2](https://adventofcode.com/2020/day/2) | 1    | 2021-11-20  | [Rust](AdventOfCode/Aoc2020/src/bin/day2_problem1.rs) |
|                                              | 2    | 2021-11-20  | [Rust](AdventOfCode/Aoc2020/src/bin/day2_problem2.rs) |
| [Day 3](https://adventofcode.com/2020/day/3) | 1    | 2021-11-27  | [Rust](AdventOfCode/Aoc2020/src/bin/day3_problem1.rs) |
|                                              | 2    | 2021-11-27  | [Rust](AdventOfCode/Aoc2020/src/bin/day3_problem2.rs) |

### 2021

| Day                                        | Part  | Date Solved | My solution                                                     | Notes                                                                                                       |
|--------------------------------------------|-------|-------------|-----------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| [1](https://adventofcode.com/2021/day/1)   | 1     | 2021-12-01  | [Rust](AdventOfCode/aoc2021/src/bin/day1_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-01  | [Rust](AdventOfCode/aoc2021/src/bin/day1_problem2.rs)           |                                                                                                             |
| [2](https://adventofcode.com/2021/day/2)   | 1     | 2021-12-02  | [Rust](AdventOfCode/aoc2021/src/bin/day2_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-02  | [Rust](AdventOfCode/aoc2021/src/bin/day2_problem2.rs)           |                                                                                                             |
| [3](https://adventofcode.com/2021/day/3)   | 1     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day3_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day3_problem2.rs)           |                                                                                                             |
| [4](https://adventofcode.com/2021/day/4)   | 1     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day4_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day4_problem2.rs)           |                                                                                                             |
| [5](https://adventofcode.com/2021/day/5)   | 1     | 2021-12-05  | [Rust](AdventOfCode/aoc2021/src/bin/day5_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-05  | [Rust](AdventOfCode/aoc2021/src/bin/day5_problem2.rs)           |                                                                                                             |
| [6](https://adventofcode.com/2021/day/6)   | 1     | 2021-12-06  | [Rust](AdventOfCode/aoc2021/src/bin/day6_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-06  | [Rust](AdventOfCode/aoc2021/src/bin/day6_problem2.rs)           |                                                                                                             |
| [7](https://adventofcode.com/2021/day/7)   | 1     | 2021-12-07  | [Rust](AdventOfCode/aoc2021/src/bin/day7_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-07  | [Rust](AdventOfCode/aoc2021/src/bin/day7_problem2.rs)           |                                                                                                             |
| [8](https://adventofcode.com/2021/day/8)   | 1     | 2021-12-08  | [Rust](AdventOfCode/aoc2021/src/bin/day8_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-08  | [Rust](AdventOfCode/aoc2021/src/bin/day8_problem2.rs)           |                                                                                                             |
| [9](https://adventofcode.com/2021/day/9)   | 1     | 2021-12-09  | [Rust](AdventOfCode/aoc2021/src/bin/day9_problem1.rs)           |                                                                                                             |
|                                            | 2     | 2021-12-09  | [Rust](AdventOfCode/aoc2021/src/bin/day9_problem2.rs)           |                                                                                                             |
| [10](https://adventofcode.com/2021/day/10) | 1     | 2021-12-10  | [Rust](AdventOfCode/aoc2021/src/bin/day10_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2021-12-10  | [Rust](AdventOfCode/aoc2021/src/bin/day10_problem2.rs)          |                                                                                                             |
| [11](https://adventofcode.com/2021/day/11) | 1 & 2 | 2021-12-11  | [Rust](AdventOfCode/aoc2021/src/bin/day11_problem1and2.rs)      |                                                                                                             |
| [12](https://adventofcode.com/2021/day/12) | 1     | 2021-12-12  | [Rust](AdventOfCode/aoc2021/src/bin/day12_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2021-12-12  | [Rust](AdventOfCode/aoc2021/src/bin/day12_problem2.rs)          |                                                                                                             |
| [13](https://adventofcode.com/2021/day/13) | 1     | 2021-12-13  | [Rust](AdventOfCode/aoc2021/src/bin/day13_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2021-12-13  | [Rust](AdventOfCode/aoc2021/src/bin/day13_problem2.rs)          |                                                                                                             |
| [14](https://adventofcode.com/2021/day/14) | 1     | 2021-12-14  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2021-12-14  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt1.rs) | Attempt 1: Would probably take 20.5 hours to run.                                                           |
|                                            | 2     | 2021-12-15  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt2.rs) | Attempt 2: 205ms using nalgebra 0.30 crate with f64 matrix elements.                                        |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt3.rs) | Attempt 3: 3.37s. Handwritten linear algebra. Messy. My Rust skills aren't good enough for this yet!        |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt4.rs) | Attempt 4: 82µs!                                                                                            |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt5.rs) | Attempt 5: 446µs. Like attempt 4, but using BTreeMap instead of arrays, due to sparsity, but it was slower. |
|                                            | 2     | 2022-01-02  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt6.rs) | Attempt 6: 1.25s using nalgebra 0.30 crate with usize matrix elements. Much slower, unfortunately.          |
| [15](https://adventofcode.com/2021/day/15) | 1     | 2021-12-20  | [Rust](AdventOfCode/aoc2021/src/bin/day15_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2021-12-20  | [Rust](AdventOfCode/aoc2021/src/bin/day15_problem2.rs)          |                                                                                                             |
| [16](https://adventofcode.com/2021/day/16) | 1     | 2021-12-23  | [Rust](AdventOfCode/aoc2021/src/bin/day16_problem1.rs)          | Feels quite elegant (albeit verbose, and without enough checking for invalid parse formats).                |
|                                            | 2     | 2021-12-23  | [Rust](AdventOfCode/aoc2021/src/bin/day16_problem2.rs)          | Part 2 easily accommodated. 544 LOC exactly evenly split between 272 lines of code and 272 of unit tests.   |
| [17](https://adventofcode.com/2021/day/17) | 1     | 2022-01-15  | [Rust](AdventOfCode/aoc2021/src/bin/day17_problem1.rs)          | Use triangular numbers for bounds of velocities. Then use brute force simulation (avoiding tricky math).    |
|                                            | 2     | 2022-01-15  | [Rust](AdventOfCode/aoc2021/src/bin/day17_problem2.rs)          |                                                                                                             |
| [18](https://adventofcode.com/2021/day/18) | 1 & 2 | 2022-03-06  | [Rust](AdventOfCode/aoc2021/src/bin/day18_problem1and2.rs)      |                                                                                                             |
| [19](https://adventofcode.com/2021/day/19) | 1 & 2 | 2022-09-21  | [Rust](AdventOfCode/aoc2021/src/bin/day19_problem1and2.rs)      | I was not looking forward to this one! Solved in 2.9 seconds using a brute force search.                    |
| [20](https://adventofcode.com/2021/day/20) | 1 & 2 | 2022-10-03  | [Rust](AdventOfCode/aoc2021/src/bin/day20_problem1and2.rs)      | Built first time. Only 1 bug (reversed order of bits in 9 bit input). Part 1 took 172µs. Part 2 took 6.8ms. |
| [21](https://adventofcode.com/2021/day/21) | 1     | 2022-10-04  | [Rust](AdventOfCode/aoc2021/src/bin/day21_problem1.rs)          |                                                                                                             |
|                                            | 2     | 2022-10-05  | [Rust](AdventOfCode/aoc2021/src/bin/day21_problem2.rs)          | Duration: 350µs.                                                                                            |
| [22](https://adventofcode.com/2021/day/22) | 1 & 2 | 2022-10-09  | [Rust](AdventOfCode/aoc2021/src/bin/day22_problem1and2.rs)      | Part 1 duration: 831ms. Part 1 and 2 combined duration: 1.46s.                                              |

### 2022

| Day | Description                                                    | Part  | Date       | Solution                                                                 | Notes                                           |
|-----|----------------------------------------------------------------|-------|------------|--------------------------------------------------------------------------|-------------------------------------------------|
| 1   | [Calorie Counting](https://adventofcode.com/2022/day/1)        | 1     | 2022-12-01 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day1_part1.py)          |                                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part1.rs)                       |                                                 |
|     |                                                                | 2     | 2022-12-01 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day1_part2.py)          |                                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part2.rs)                       | Duration: 107µs                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part2_fast.rs)                  | Duration: 98µs                                  |
| 2   | [Rock Paper Scissors](https://adventofcode.com/2022/day/2)     | 1     | 2022-12-02 | [Rust](AdventOfCode/aoc2022/src/bin/day2_part1.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day2_part1.py)          | Succinct, but too much magic in formula!        |
|     |                                                                | 2     | 2022-12-02 | [Rust](AdventOfCode/aoc2022/src/bin/day2_part2.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day2_part2.py)          |                                                 |
| 3   | [Rucksack Reorganization](https://adventofcode.com/2022/day/3) | 1     | 2022-12-03 | [Rust](AdventOfCode/aoc2022/src/bin/day3_part1.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part1.py)          | Using list comprehensions                       |
|     |                                                                |       | 2022-12-04 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part1_for_loop.py) | Using for loop (longer, but more readable)      |
|     |                                                                | 2     | 2022-12-03 | [Rust](AdventOfCode/aoc2022/src/bin/day3_part2.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part2.py)          | Using list comprehensions                       |
|     |                                                                |       | 2022-12-04 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part2_for_loop.py) | Using for loop (longer, but more readable)      |
| 4   | [Camp Cleanup](https://adventofcode.com/2022/day/4)            | 1 & 2 | 2022-12-04 | [Rust](AdventOfCode/aoc2022/src/bin/day4_part1and2.rs)                   |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day4_part1and2.py)      |                                                 |
| 5   | [Supply Stacks](https://adventofcode.com/2022/day/5)           | 1 & 2 | 2022-12-05 | [Rust](AdventOfCode/aoc2022/src/bin/day5_part1and2.rs)                   |                                                 |
| 6   | [Tuning Trouble](https://adventofcode.com/2022/day/6)          | 1 & 2 | 2022-12-06 | [Rust](AdventOfCode/aoc2022/src/bin/day6_part1and2.rs)                   | Efficient. 43 LOC.                              |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day6_part1and2_windows.rs)           | 23 LOC (excluding unit tests). Over 10x slower. |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day6_part1and2.py)      | Succinct. 9 LOC.                                |
| 7   | [No Space Left On Device](https://adventofcode.com/2022/day/7) | 1 & 2 | 2023-04-23 | [Rust](AdventOfCode/aoc2022/src/bin/day7.rs)                             | Verbose.                                        |
|     |                                                                |       | 2023-05-08 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day7_part1and2.py)      |                                                 |
| 8   | [Treetop Tree House](https://adventofcode.com/2022/day/8)      | 1 & 2 |            | [Rust](AdventOfCode/aoc2022/src/bin/day8.rs)                             |                                                 |
| 9   | [Rope Bridge](https://adventofcode.com/2022/day/9)             | 1     | 2023-05-13 | [Rust](AdventOfCode/aoc2022/src/bin/day9_part1.rs)                       |                                                 |
|     |                                                                | 2     | 2023-05-14 | [Rust](AdventOfCode/aoc2022/src/bin/day9_part2.rs)                       | Duration: 655µs (excl. I/O).                    |

## cryptopals crypto challenges

### Solutions for [Set 1](https://cryptopals.com/sets/1)

| Challenge | Description                                                               | Date Solved | Solution                                                  | Notes                                                                                                                                                                      |
|-----------|---------------------------------------------------------------------------|-------------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| #1        | [Convert hex to base64](https://cryptopals.com/sets/1/challenges/1)       | 2021-11-20  | [Rust](cryptopals/src/bin/challenge1.rs)             |                                                                                                                                                                                 |
| #2        | [Fixed XOR](https://cryptopals.com/sets/1/challenges/2)                   | 2021-12-01  | [Rust](cryptopals/src/bin/challenge2.rs)             |                                                                                                                                                                                 |
| #3        | [Single-byte XOR cipher](https://cryptopals.com/sets/1/challenges/3)      | 2021-12-03  | [Rust](cryptopals/src/bin/challenge3.rs)             | Order histogram of chars and find min variance of positions from frequency histogram.                                                                                           |
|           |                                                                           | 2022-01-15  | [Rust](cryptopals/src/bin/challenge3_alpha_count.rs) | Count lowercase ASCII letters twice, and uppercase once and use the key with the max score.                                                                                     |
| #4        | [Detect single-character XOR](https://cryptopals.com/sets/1/challenges/4) | 2022-01-15  | [Rust](cryptopals/src/bin/challenge4.rs)             | Naive ASCII score fails. More complex ascii score works, taking 15 ms. Letter frequency histogram approach takes 131 ms.                                                        |
| #5        | [Implement repeating-key XOR](https://cryptopals.com/sets/1/challenges/5) | 2022-05-29  | [Rust](cryptopals/src/bin/challenge5.rs)             | The repeating key XOR encryption function was added to lib.rs.                                                                                                                  |
| #6        | [Break repeating-key XOR](https://cryptopals.com/sets/1/challenges/6)     | 2022-06-28  | [Rust](cryptopals/src/bin/challenge6.rs)             | lib.rs was broken into various sub-modules including [base64](cryptopals/src/base64.rs) and [cipher::repeating_key_xor](cryptopals/src/ciphers/repeating_key_xor.rs) utilities. |
| #7        | [AES in ECB mode](https://cryptopals.com/sets/1/challenges/7)             | 2022-07-01  | [Rust](cryptopals/src/bin/challenge7.rs)             | [ciphers::aes](cryptopals/src/ciphers/aes.rs) wraps the call to the rust [openssl crate](https://crates.io/crates/openssl).                                                     |
| #8        | [Detect AES in ECB mode](https://cryptopals.com/sets/1/challenges/8)      | 2022-07-03  | [Rust](cryptopals/src/bin/challenge8.rs)             |                                                                                                                                                                                 |

## CSES Problem Set

### Introductory Problems

| # | Description                                              | Date       | Solution                                      | Notes                                                      |
|---|----------------------------------------------------------|------------|-----------------------------------------------|------------------------------------------------------------|
| 1 | [Weird Algorithm](https://cses.fi/problemset/task/1068)  | 2022-05-28 | [Rust](cses_rust/src/bin/weird_algorithm.rs)  |                                                            |
| 2 | [Missing Number](https://cses.fi/problemset/task/1083/)  | 2022-05-28 | [Rust](cses_rust/src/bin/missing_number.rs)   |                                                            |
| 3 | [Repetitions](https://cses.fi/problemset/task/1069)      | 2022-05-29 | [Rust](cses_rust/src/bin/repetitions.rs)      |                                                            |
| 4 | [Increasing Array](https://cses.fi/problemset/task/1094) | 2022-06-04 | [Rust](cses_rust/src/bin/increasing_array.rs) |                                                            |
| 5 | [Permutations](https://cses.fi/problemset/task/1070/)    | 2022-06-05 | [Rust](cses_rust/src/bin/permutations.rs)     |                                                            |
| 6 | [Number Spiral](https://cses.fi/problemset/task/1071/)   | 2022-06-29 | [Rust](cses_rust/src/bin/number_spiral.rs)    |                                                            |
| 7 | [Two Knights](https://cses.fi/problemset/task/1072/)     | 2022-08-09 | [Rust](cses_rust/src/bin/two_knights.rs)      |                                                            |
| 8 | [Two Sets](https://cses.fi/problemset/task/1092/)        | 2022-08-21 | [Rust](cses_rust/src/bin/two_sets.rs)         | Elegant and obviously correct, but probably not efficient. |
|   |                                                          | 2022-08-21 | [Rust](cses_rust/src/bin/two_sets_v2.rs)      | Clever and efficient, but not obvious.                     |
| 9 | [Bit Strings](https://cses.fi/problemset/task/1617/)     | 2023-05-17 | [Rust](cses_rust/src/bin/bit_strings.rs)      | A simple, brute force approach, but fast enough.           |

## Katas from CodingDojo.org

| Exercise                                                     | Description                                    | Date       | Solution                                                                                                             | Notes                                                                                                                       |
|--------------------------------------------------------------|------------------------------------------------|------------|----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| [Bowling scorer](https://codingdojo.org/kata/Bowling/)       | Ten pin bowling scoring algorithm              | 2015-09-25 | [C# (v1)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer.cs)              | [readme](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling)                                       |
|                                                              |                                                | 2015-09-25 | [C# (v2 - stateless)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer2.cs) |                                                                                                                             |
|                                                              |                                                | 2015-09-27 | [C# (v3 - immutable)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer3.cs) |                                                                                                                             |
|                                                              |                                                | 2015-09-27 | [F#](Katas/CodingDojo/Bowling/DotNet/src/main/fsharp/AndrewTweddle.Katas.Bowling.FSharp/FunctionalBowlingScorer.fs)  |                                                                                                                             |
|                                                              |                                                | 2015-09-25 | [unit tests](Katas/CodingDojo/Bowling/DotNet/src/test/csharp/AndrewTweddle.Katas.Test.Bowling)                       |                                                                                                                             |
|                                                              |                                                | 2022-10-27 | [Rust](Katas/CodingDojo/Bowling/rust_bowl)                                                                           | Project directory for a typed and validated bowling scorer in Rust. It's verbose but checks many extra corner cases.        |
|                                                              |                                                |            | [lib.rs](Katas/CodingDojo/Bowling/rust_bowl/src/lib.rs)                                                              | Shared types, utility functions and an error enum. The [thiserror](https://github.com/dtolnay/thiserror) crate is used.     |
|                                                              |                                                |            | [pattern_scorer.rs](Katas/CodingDojo/Bowling/rust_bowl/src/pattern_scorer.rs)                                        | Use pattern matching over array slices of `Throw`'s to calculate the score (similar to the F# solution). Unit tests inline. |
| [Roman Numerals](https://codingdojo.org/kata/RomanNumerals/) | Convert to and from Roman numerals up to 3000. | 2021-06-01 | [README file](Katas/CodingDojo/RomanNumerals/README.md)                                                              | This discusses the various experiments below.                                                                               |
|                                                              |                                                | 2021-05-11 | [Rust (TDD)](Katas/CodingDojo/roman_numerals/src/main.rs)                                                            | Experiment with TDD and with quickcheck property-based testing.                                                             |
|                                                              |                                                | 2021-05-24 | [Rust v2](Katas/CodingDojo/RomanNumerals/Rust/roman_numerals_v2/src/main.rs)                                         | Designed intuitively, not iteratively to compare with the TDD approach. Experiment with proptest property-based testing.    |
|                                                              |                                                | 2021-06-02 | [Rust v3](Katas/CodingDojo/RomanNumerals/Rust/roman_numerals_v3/src/main.rs)                                         | A simpler approach (unfortunately not mine - I saw others doing this, and rewrote it in Rust).                              |

## Miscellaneous

| Exercise                                                                  | Description                                                     | Date       | Solution                                                                                                           |
|---------------------------------------------------------------------------|-----------------------------------------------------------------|------------|--------------------------------------------------------------------------------------------------------------------|
| [wordrect](misc/WordRectangles) - [readme](misc/WordRectangles/readme.md) | Largest rectangle of letters with words in every row and column | 2020-01-19 | [Scala prototype (v1)](misc/WordRectangles/Scala_v1/src/main/scala/com/andrewtweddle/wordrects/WordRectMain.scala) |
|                                                                           |                                                                 | 2020-01-25 | [C++ prototype (v1)](misc/WordRectangles/Cpp_v1/main.cpp)                                                          | 

## CTCI

The CTCI sub-folder contains my solutions to exercises from the 5th edition of [Cracking the Coding Interview](http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X) by Gayle Laakmann McDowell.

| Exercise | Description                                               | My solutions                                                                                                                                       |
|----------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 1.1      | Check for duplicate letters in a string                   | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise1/DuplicateLetterChecker.cs)                                                  |
| 1.3      | Check if two strings are permutations                     | [C# (readable)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise3/SimplePermutationChecker.cs)                                     |
|          |                                                           | [C# (fast)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise3/QuickPermutationChecker.cs)                                          |
| 2.1      | Remove duplicate letters from a linked list               | [C# (fast)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise1/QuickDuplicateLetterRemover.cs)                                      |
|          |                                                           | [C# (without temporary buffer)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise1/DuplicateLetterRemoverWithoutTemporaryBuffer.cs) |
| 3.1      | Implement multiple stacks in a single array               | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter3/Exercise1/StackArray.cs)                                                              |
| 3.1      | Repeat as a challenge, using array space more effectively | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter3/Exercise1Challenge/Stacker.cs)                                                        |
| 4.1      | Determine if a binary tree is balanced                    | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter4/Exercise1/BinaryTreeBalanceChecker.cs)                                                |
| 5.1      | Overwrite bits in one int from another                    | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter5/Exercise1/BitInserter.cs)                                                             |
| 9.1      | Number of different ways of hopping up stairs             | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter9/Exercise1/StepsSolver.cs)                                                             |
| 1.4      | Replacing spaces with "%20" in a string                   | [Scala](CTCI/Scala/src/main/scala/ctci/chapter1/Exercise4.scala)                                                                                   |
| 2.2      | kth to last node in a linked list                         | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise2/Node.cs)                                                                    |

## Functional Programming In Scala

Exercises from the book
["Functional Programming in Scala"](http://www.manning.com/bjarnason/)
are in [a separate GitHub project](https://github.com/AndrewTweddle/fpinscala)
which was forked from [the original FPInScala repo](https://github.com/fpinscala/fpinscala)
for the book.

# Learnings and notes

## General approach

_Note: This is the approach I was experimenting with in 2015. It can be quite onerous and slow (compared to a more intuitive approach)._

### Follow a miniaturised SDLC

* Analysis
  * Summarize the problem statement (preferably highlighting critical clauses)
  * Confirm the scope
  * Question the requirements
  * Look for simplifying assumptions
  * List any issues that complicate things (and consider unit testing these earlier)
* Design
  * Brainstorm a number of solutions
    * Count number of steps and estimate the big-O scalability of each
    * Decide which solution to implement
      * Check the stakeholder's preferences when there is a trade-off (e.g. speed versus maintainability)
      * Otherwise, favour clarity over cleverness
    * Look for utility methods which could be useful across multiple solutions
  * Do UML designs if necessary
  * Do pseudocode if useful
    * Be alert for useful utility methods to make the main algorithm more readable
* Code
  * If there are multiple algorithms to implement, create a base class and a derived class per algorithm
* Unit test
  * If there are multiple algorithms to test, create a base class and a derived unit test class per implementation
* Code review
  * Look at the code critically
  * Refactor, add TODO's or make a note of areas that could be improved
* Compare
  * If a commonly used Kata (e.g. the bowling game), see how others have solved it and compare to my solution

### Use a notebook to write all code on paper first

* Ideally I wanted to use my whiteboard for all steps in this mini SDLC, but it was already in use
* Instead, I used a notebook to do analysis, design, coding and unit testing
* Once done I would capture and compile the code and unit tests electronically
  * An exception was exercise 4.1, which I coded directly.
  * The quality of the code in this exercise is noticeably worse, so pre-planning on paper is clearly worthwhile
  * I was initially skeptical of doing whiteboard coding in interviews, as this is not common practice in South Africa
  * However, I am already seeing benefits from doing this:
    * Improved designs through adding greater structure and focus to the creative process
    * An improved ability to "play out" detailed coding scenarios in my head
* I then fixed coding errors or refactored the code and made notes on these errors and refactorings
* After each exercise I add any language-specific notes and reminders to the sections below

  
## C\# 

| Purpose                       | Solution                                                                 | Notes                                                                                                                                                       |
|-------------------------------|--------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Sets                          | HashSet&lt;T&gt;                                                         | Useful methods: Add and Contains.                                                                                                                           |
| Hash maps                     | Dictionary&lt;K, V&gt;                                                   | Useful methods: ContainsKey, Keys, Values, enumerator over KeyValuePair&lt;K, V&gt;                                                                         |
| Test multiple implementations | MSTest: [TestMethod] on base class methods, [TestClass] on derived class | The derived unit test class chooses which implementation to use. The base class defines the common tests.                                                   |
| Assert.AreEqual               | Parameters: expected then actual                                         |                                                                                                                                                             |
| Int to binary string          | Convert.ToString(value, 2 )                                              | Useful for making unit test more readable. See [exercise 5.1](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI.Tests/Chapter5/Exercise1/WhenInsertingBits.cs) |
| Binary string to int          | Convert.ToInt32(str, 2 )                                                 | The second parameter is the base. See [exercise 5.1](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI.Tests/Chapter5/Exercise1/WhenInsertingBits.cs)          |
| Validate arguments            | ArgumentException(message, paramName )                                   | The parameter name is the second parameter to the constructor.                                                                                              |
| Validate argument range       | ArgumentOutOfRangeException(paramName, message)                          | But this time the parameter name is the first parameter to the constructor!                                                                                 |
| Overflow checking             | checked { ... }                                                          | Arithmetic overflow is silent unless the statement/s (NOT expressions) are in a checked block                                                               |
| Initialize dictionary         | ... = { {key; value}, ... }                                              |                                                                                                                                                             |

## Other coding tips

1. Whenever adding to an int, consider whether the expression should be in a checked block "{}" to catch overflows.
2. "for (int i = 0; i <= n; i++)" - consider whether n could be int.MaxValue, which would cause overflow. If so, consider summing in reverse.

## General approach

1. When faced with a "monolithic method", consider applying separation of concerns, even if this causes some duplication or multiple passes through a (small) iteration.
2. In the above case, consider refactoring out smaller methods first, as this might reduce duplication.
