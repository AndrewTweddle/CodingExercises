# Overview

This project contains my solutions to various coding exercises.

I use these to:
* practise coding skills,
* learn new programming languages,
* compare languages or paradigms,
* prepare for technical interviews, and (last but **not** least)
* have fun solving coding puzzles!
  
## Links within this page

| Link                                                                                                          | Source                                                      | Description                                  |
|---------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|----------------------------------------------|
| [Project Euler](#project-euler-problems)                                                                      | [projecteuler.net](https://projecteuler.net)                | Coding challenges with a mathematical theme  |
| [Advent of Code](#advent-of-code) ([2020](#2020), [2021](#2021), [2022](#2022), [2023](#2023), [2024](#2024)) | [adventofcode.com](https://adventofcode.com/)               | 25 days of coding challenges run in December |
| [cryptopals](#cryptopals-cryptography-challenges)                                                             | [cryptopals.com](https://cryptopals.com/)                   | Cryptography challenges                      |
| [CSES Problem Set](#cses-problem-set)                                                                         | [cses.fi/problemset/list](https://cses.fi/problemset/list/) | Competitive coding exercises                 |
| [CodingDojo Katas](#katas-from-codingdojoorg)                                                                 | [CodingDojo.org](https://codingdojo.org/)                   |                                              |
| [Miscellaneous](#miscellaneous)                                                                               | Miscellaneous sources                                       |                                              |
| [CTCI Exercises](#ctci)                                                                                       | The book "Cracking the Coding Interview"                    | Technical interview questions                |

## Related repositories

| Repository                                                                    | Description                                                                                           |
|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|
| [AndrewTweddle/GoogleCodeJam](https://github.com/AndrewTweddle/GoogleCodeJam) | Submissions to the Google CodeJam algorithmic coding competition                                      |
| [AndrewTweddle/CodeForces](https://github.com/AndrewTweddle/CodeForces)       | My entries to various [CodeForces](https://codeforces.com/) algorithmic coding contests               |
| [AndrewTweddle/fpinscala](https://github.com/AndrewTweddle/fpinscala)         | Forked exercises from the book ["Functional Programming in Scala"](http://www.manning.com/bjarnason/) |

# The exercises

## Project Euler problems

Project Euler requests that solutions not be shared online for problems beyond #100.

| #  | Description                                                                  | Date       | Solution                                                             | Duration (i7-6700) | Duration (M4 Pro) | Notes                                                                                                                                                                                                                                       |
|----|------------------------------------------------------------------------------|------------|----------------------------------------------------------------------|--------------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | [Multiples of 3 and 5](https://projecteuler.net/problem=1)                   | 2021-04-11 | [Rust](project_euler/src/bin/problem1.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 2  | [Even Fibonacci Numbers](https://projecteuler.net/problem=2)                 | 2021-04-12 | [Rust](project_euler/src/bin/problem2.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 3  | [Largest Prime Factor](https://projecteuler.net/problem=3)                   | 2021-04-12 | [Rust](project_euler/src/bin/problem3.rs)                            |                    |                   | Experimented with, and timed, various methods of calculating primes.                                                                                                                                                                        |
| 4  | [Largest Palindrome Product](https://projecteuler.net/problem=4)             | 2021-04-12 | [Rust](project_euler/src/bin/problem4.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 5  | [Smallest Multiple](https://projecteuler.net/problem=5)                      | 2021-04-12 | [Rust](project_euler/src/bin/problem5.rs)                            |                    |                   | Calculate lcm of 2 to 20 using gcd and reduce.                                                                                                                                                                                              |
|    |                                                                              | 2021-04-12 | [Rust](project_euler/src/bin/problem5_v2.rs)                         |                    |                   | Calculate lcm of 2 to 20 using primes.                                                                                                                                                                                                      |
| 6  | [Sum square difference](https://projecteuler.net/problem=6)                  | 2021-04-12 | [Rust](project_euler/src/bin/problem6.rs)                            |                    |                   | Very short and creative solution: sum of squares - square of sums = sum of squares - sum of cubes.                                                                                                                                          |
| 7  | [10001st prime](https://projecteuler.net/problem=7)                          | 2021-04-13 | [Rust](project_euler/src/bin/problem7.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 8  | [Largest product in a series](https://projecteuler.net/problem=8)            | 2021-04-13 | [Rust](project_euler/src/bin/problem8.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 9  | [Special Pythagorean triplet](https://projecteuler.net/problem=9)            | 2021-04-14 | [Rust](project_euler/src/bin/problem9.rs)                            |                    |                   |                                                                                                                                                                                                                                             |
| 10 | [Summation of primes](https://projecteuler.net/problem=10)                   | 2021-04-15 | [Rust](project_euler/src/bin/problem10.rs)                           |                    |                   | Includes performance comparison of getting primes using 3 variants on the Sieve of Eratosthenes (see [Wikipedia](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_and_variants)).                                              |
| 11 | [Largest product in a grid](https://projecteuler.net/problem=11)             | 2021-04-16 | [Rust](project_euler/src/bin/problem11.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 12 | [Highly divisible triangular number](https://projecteuler.net/problem=12)    | 2021-04-17 | [Rust](project_euler/src/bin/problem12.rs)                           |                    |                   | Duration: 182.176 ms. Original attempt. Succinct but slow, because `i*i <= n` is performed repeatedly in the innermost loop.                                                                                                                |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_sqrt_bounds_binary_search.rs) | 133 ms.            | 29 ms.            | Do binary search for integer square root based on lower and upper integer bounds. Still slow, even though int sqrt is outside the inner loop.                                                                                               |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_rel_prime_divisors.rs)        | 2.400 ms.          | 375 µs.           | I had a brainwave! T(n) = n*(n+1)/2. n and n+1 are relatively prime. Hence # of divisors of T(n) is the product of # of divisors of n/2 and n+1 (if n is even) or n and (n+1)/2 if odd.                                                     |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_prime_factors.rs)             | 1.540 ms.          | 291 µs.           | As above, but also pre-generate a few primes and further decompose each divisor by these primes before counting the # of divisors. 30 makes a good cut-off, so factorize up to 29.                                                          |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_const_prime_factors.rs)       | 853 µs.            | 202 µs.           | As above, but hard-coding the primes up to 31, instead of calculating them on the fly.                                                                                                                                                      |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_primes_6q_plus_r.rs)          | 734 µs.            | 203 µs.           | As above, but only count divisors of the remainder (after reducing by primes up to 31) of the form 6q+1 or 6q+5.                                                                                                                            |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_primes_30q_plus_r.rs)         | 845 µs.            | 213 µs.           | As above, but only count divisors of the remainder (after reducing by small primes) of the form 30q+r for suitable r. This is slower for n=500, but scales well for much higher values.                                                     |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_const_prime_factors_mpsc.rs)  | 5.598 ms.          | 2.19 ms.          | Using hard-coded primes, with mpsc (5 threads works well on my PC). Perhaps unsurprisingly, this is much slower since we are not I/O bound. It catches up for very large n (> 10,000).                                                      |
|    |                                                                              | 2021-09-06 | [Rust](project_euler/src/bin/problem12_repeated_factorization.rs)    | 1.735 ms.          | 352 µs.           | Instead of pre-computing or hard-coding primes, completely factorize into primes on the fly. Although slower, this solution is shorter and more elegant.                                                                                    |
| 13 | [Large sum](https://projecteuler.net/problem=13)                             | 2021-04-17 | [Rust](project_euler/src/bin/problem13.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 14 | [Longest Collatz sequence](https://projecteuler.net/problem=14)              | 2021-04-19 | [Rust](project_euler/src/bin/problem14.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 15 | [Lattice paths](https://projecteuler.net/problem=15)                         | 2021-04-30 | [Rust](project_euler/src/bin/problem15.rs)                           | 13.4 µs.           |                   | Calculate combinatorial without overflow by aggressively cancelling common factors from numerators & denominators.                                                                                                                          |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem15_diagonal_sweep.rs)            | 18.7 µs.           |                   | Calculate paths from top left to bottom right by doing a "diagonal sweep", calculating distances to each point on a diagonal based on the previous diagonal.                                                                                |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem15_fast_combinatorial.rs)        | 11.3 µs.           |                   | I converted someone else's C++ solution to Rust. Calculate a combinatorial by generating and iterating through all relevant primes and calculating its contribution to each factorial.                                                      |
| 16 | [Power digit sum](https://projecteuler.net/problem=16)                       | 2021-05-02 | [Rust](project_euler/src/bin/problem16.rs)                           | 13.1 µs.           |                   | Problem: Sum the decimal digits in 2^1000. Solution: Use base 10^19 < 2^64. Store digits as u128. So squaring a digit and adding a carry will not overflow. 2^1000 = ((((2^125)^2)^2)^2.                                                    |
|    |                                                                              | 2021-05-02 | [Rust](project_euler/src/bin/problem16_decimal_digits.rs)            | 951.9 µs.          |                   | By contrast, calculating one decimal digit at a time is very slow, showing how neat the previous solution is! However, it is much simpler and shorter to do one decimal digit at a time.                                                    |
|    |                                                                              | 2021-05-03 | [Rust](project_euler/src/bin/problem16_bigint.rs)                    | 5.3 µs.            |                   | Using the num-bigint crate.                                                                                                                                                                                                                 |
|    |                                                                              | 2021-05-04 | [Rust](project_euler/src/bin/problem16_bigint_fast.rs)               | 4.9 µs.            |                   | Using the num-bigint crate and calculating digits by dividing by 10 and taking remainders, not by converting to a string and iterating over chars.                                                                                          |
|    |                                                                              | 2021-05-10 | [Rust](project_euler/src/bin/problem16_rayon.rs)                     | 45.8 µs.           |                   | Using the original approach, but summing the digits in parallel using the rayon crate (as a way of learning rayon). This was MUCH slower.                                                                                                   |
|    |                                                                              | 2021-05-10 | [Rust](project_euler/src/bin/problem16_original_fast.rs)             | 10.767 µs.         |                   | Using the original approach again, but calculating the digits by dividing by 10 and taking remainders.                                                                                                                                      |
| 17 | [Number Letter Counts](https://projecteuler.net/problem=17)                  | 2021-05-20 | [Rust](project_euler/src/bin/problem17_tdd_collab.rs)                | 373 µs.            |                   | TDD solution pair programmed with a colleague (for him to show me how he does TDD, and for me to show him Rust). proptest crate also used for property-based testing of the algorithm.                                                      |
|    |                                                                              | 2021-05-20 | [Rust](project_euler/src/bin/problem17.rs)                           | 9 ns.              |                   | Coded on my own using a more intuitive approach. This was simple, succinct and lightning fast, but also brittle and tricky to get right.                                                                                                    |
| 18 | [Maximum path sum I](https://projecteuler.net/problem=18)                    | 2021-05-31 | [Rust](project_euler/src/bin/problem18.rs)                           | 1.228 µs.          |                   |                                                                                                                                                                                                                                             |
|    |                                                                              | 2021-05-31 | [Rust](project_euler/src/bin/problem18_combinators.rs)               | 1.915 µs.          |                   | Same algorithm, but using combinators instead of manual loops.                                                                                                                                                                              |
| 19 | [Counting Sundays](https://projecteuler.net/problem=19)                      | 2021-06-01 | [Rust](project_euler/src/bin/problem19.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 20 | [Factorial digit sum](https://projecteuler.net/problem=20)                   | 2021-06-06 | [Rust](project_euler/src/bin/problem20.rs)                           | 15.009 µs.         |                   | Problem: Sum of digits in 100! Solution: Calculate factorial using a vector representing digits in base 10^36, since 100*(10^36-1)+max_carry_digit will not overflow a u128.                                                                |
|    |                                                                              | 2021-06-06 | [Rust](project_euler/src/bin/problem20_prime_factors.rs)             | 18.875 µs.         |                   | Determine factorial from prime factors, one prime at a time. Since n/p numbers in n! have p as a factor, n/(p^2) have another factor p, etc. Use base 10^19 to avoid overflowing a u128.                                                    |
|    |                                                                              | 2022-01-03 | [Rust](project_euler/src/bin/problem20_bigint.rs)                    | 3.221 µs.          |                   | Using the num-bigint crate.                                                                                                                                                                                                                 |
| 21 | [Amicable numbers](https://projecteuler.net/problem=21)                      | 2021-07-04 | [Rust](project_euler/src/bin/problem21.rs)                           | 419 µs.            |                   | Two similar solutions are provided. The one using a lookup table is about 6000 times faster.                                                                                                                                                |
|    |                                                                              | 2021-07-04 | [Rust](project_euler/src/bin/problem21_using_primes.rs)              | 74.145 ms.         |                   | Uses primes. Suppose n has prime factorization p1^e1 * p2^e2 * ... * pk^ek. then the sum of divisors of n is (1+p1+p1^2+...+p1^e1) * (1+p2+p2^2+...+p2^e2) * ... * (1+pk+pk^2+...+pk^ek).                                                   |
| 22 | [Names scores](https://projecteuler.net/problem=22)                          | 2021-07-17 | [Rust](project_euler/src/bin/problem22.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 23 | [Non-abundant sums](https://projecteuler.net/problem=23)                     | 2021-08-23 | [Rust](project_euler/src/bin/problem23.rs)                           | 1.176 s.           |                   | Simple but slow approach.                                                                                                                                                                                                                   |
|    |                                                                              | 2021-08-23 | [Rust](project_euler/src/bin/problem23_sum_abund_pairs.rs)           | 27 ms.             |                   | More verbose, but MUCH faster!                                                                                                                                                                                                              |
| 24 | [Lexicographic permutations](https://projecteuler.net/problem=24)            | 2021-08-23 | [Rust](project_euler/src/bin/problem24.rs)                           | 385 ns.            |                   |                                                                                                                                                                                                                                             |
|    |                                                                              | 2021-08-23 | [Rust](project_euler/src/bin/problem24_mixed_radix.rs)               | 343 ns.            |                   | Flash of inspiration here! The millionth lexicographic sort of the 10 decimal digits is simply 999,999 expressed in the [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system)!                                   |
| 25 | [1000-digit Fibonacci number](https://projecteuler.net/problem=25)           | 2021-09-25 | [Rust](project_euler/src/bin/problem25.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 26 | [Reciprocal cycles](https://projecteuler.net/problem=26)                     | 2021-10-19 | [Rust](project_euler/src/bin/problem26.rs)                           | 1.377 ms.          |                   |                                                                                                                                                                                                                                             |
|    |                                                                              | 2021-10-20 | [Rust](project_euler/src/bin/problem26_fast.rs)                      | 966 µs.            |                   |                                                                                                                                                                                                                                             |
| 27 | [Quadratic primes](https://projecteuler.net/problem=27)                      | 2021-11-14 | [Rust](project_euler/src/bin/problem27.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 28 | [Number spiral diagonals](https://projecteuler.net/problem=28)               | 2021-11-17 | [Rust](project_euler/src/bin/problem28.rs)                           |                    |                   |                                                                                                                                                                                                                                             |
| 29 | [Distinct powers](https://projecteuler.net/problem=29)                       | 2021-11-17 | [Rust](project_euler/src/bin/problem29.rs)                           | 2.70 ms.           |                   | Problem: count distinct a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100. Solution: Generate prime representation of a's, multiply exponents by each b. Add to a set to eliminate duplicates.                                                            |
|    |                                                                              | 2021-11-17 | [Rust](project_euler/src/bin/problem29_bruteforce.rs)                | 2.47 ms.           |                   | Alternate solution: Represent a's as a Vec<u128> of digits in base 2^120 (so that a u128 digit doesn't overflow if multiplied by 100 or any smaller value of a). Add to a set to eliminate duplicates.                                      |
|    |                                                                              | 2022-01-03 | [Rust](project_euler/src/bin/problem29_bigint.rs)                    | 2.62 ms.           |                   | Using the num-bigint crate.                                                                                                                                                                                                                 |
| 30 | [Digit fifth powers](https://projecteuler.net/problem=30)                    | 2022-01-06 | [Rust](project_euler/src/bin/problem30.rs)                           | 8.9 ms.            |                   |                                                                                                                                                                                                                                             |
| 31 | [Coin sums](https://projecteuler.net/problem=31)                             | 2022-03-22 | [Rust](project_euler/src/bin/problem31.rs)                           | 14 µs.             |                   |                                                                                                                                                                                                                                             |
| 32 | [Pandigital products](https://projecteuler.net/problem=32)                   | 2022-03-23 | [Rust](project_euler/src/bin/problem32.rs)                           | 28 ms.             |                   |                                                                                                                                                                                                                                             |
| 33 | [Digit cancelling fractions](https://projecteuler.net/problem=33)            | 2022-03-24 | [Rust](project_euler/src/bin/problem33.rs)                           | 286 µs.            |                   |                                                                                                                                                                                                                                             |
| 34 | [Digit factorials](https://projecteuler.net/problem=34)                      | 2022-05-28 | [Rust](project_euler/src/bin/problem34.rs)                           | 9.1 ms.            |                   |                                                                                                                                                                                                                                             |
| 35 | [Circular primes](https://projecteuler.net/problem=35)                       | 2022-06-05 | [Rust](project_euler/src/bin/problem35.rs)                           | 7.0 ms.            | 3.86 ms.          |                                                                                                                                                                                                                                             |
| 36 | [Double-base palindromes](https://projecteuler.net/problem=36)               | 2022-07-13 | [Rust](project_euler/src/bin/problem36.rs)                           | 107.5 ms.          |                   | Using string comparisons.                                                                                                                                                                                                                   |
|    |                                                                              | 2022-07-13 | [Rust](project_euler/src/bin/problem36_fast.rs)                      | 6.1 ms.            |                   | Much faster! (But almost double the code.) - No string conversions. Check reversal of bits (fast) then check decimal digits for a palindrome.                                                                                               |
|    |                                                                              | 2022-07-13 | [Rust](project_euler/src/bin/problem36_loop_over_3_digits.rs)        | 13 µs.             |                   | A beautiful solution and way, way faster! Use 3 nested loops over the 3 lowest digits of the decimal palindrome, generating decimal palindromes between 1 and 6 digits long. Test if each is a binary palindrome.                           |
|    |                                                                              | 2022-08-10 | [Rust](project_euler/src/bin/problem36_recurse_over_digits.rs)       | 16.1 µs.           |                   | Generalize the previous algorithm to work for any value of n, not just 1 million.                                                                                                                                                           |
| 37 | [Truncatable primes](https://projecteuler.net/problem=37)                    | 2022-08-19 | [Rust](project_euler/src/bin/problem37.rs)                           | 94 µs.             |                   | Crude approach for testing primality: See if number is of the form 6n +/- 1. If so, only check factors of the form 6k +/- 1. Reason: all primes except 2 and 3 are of the form 6n-1 or 6n+1.                                                |
|    |                                                                              | 2022-08-21 | [Rust](project_euler/src/bin/problem37_cache_primes.rs)              | ∞?                 | ∞?                | DO NOT RUN! Instructive only! This runs indefinitely and uses LOTS of memory! As above, but this tests for primality by caching primes up to some number. If this number is exceeded, the cache is recalculated to a higher limit.          |
| 38 | [Pandigital multiples](https://projecteuler.net/problem=38)                  | 2022-09-07 | [Rust](project_euler/src/bin/problem38.rs)                           | 137 µs.            |                   | Efficient but not particularly clever, mathematically. But creating an iterator over the digits of a number was a nice touch.                                                                                                               |
| 39 | [Integer right triangles](https://projecteuler.net/problem=39)               | 2022-09-11 | [Rust](project_euler/src/bin/problem39.rs)                           | 57 ms.             |                   | A brute force approach: quick to write, but quite slow to run.                                                                                                                                                                              |
|    |                                                                              | 2022-09-17 | [Rust](project_euler/src/bin/problem39_v2.rs)                        | 3 µs.              |                   | Using [the formula for generating Pythagorean triples](https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple) and iterating over possible values of m,n,k to generate valid perimeters.                                      |
|    |                                                                              | 2022-09-18 | [Rust](project_euler/src/bin/problem39_v3.rs)                        | 480 µs.            |                   | Using [the formula for generating Pythagorean triples](https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple) and factorizing the perimeter to count valid combinations of m,n and k.                                        |
| 40 | [Champernowne's constant](https://projecteuler.net/problem=40)               | 2023-04-12 | [Rust](project_euler/src/bin/problem40.rs)                           | 48 ns              |                   |                                                                                                                                                                                                                                             |
| 41 | [Pandigital prime](https://projecteuler.net/problem=41)                      | 2023-05-14 | [Rust](project_euler/src/bin/problem41.rs)                           | 5.7 µs.            |                   | Used the [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system) to implement a descending iterator over pandigital numbers.                                                                                       |
| 42 | [Coded triangle numbers](https://projecteuler.net/problem=42)                | 2023-05-21 | [Rust](project_euler/src/bin/problem42.rs)                           |                    |                   | Using 8 T(n) + 1 = (2n+1)^2, where T(n) is the triangular number formula, along with an integer square root (floor of the sqrt) [algorithm](https://en.wikipedia.org/wiki/Integer_square_root#Using_bitwise_operations).                    |
| 43 | [Sub-string divisibility](https://projecteuler.net/problem=43)               | 2023-05-22 | [Rust](project_euler/src/bin/problem43.rs)                           | 306 ms.            |                   | The [factorial number system](https://en.wikipedia.org/wiki/Factorial_number_system) was used to implement a `TenDigitPandigitalIter` (double-ended for unit testing purposes).                                                             |
| 44 | [Pentagon Numbers](https://projecteuler.net/problem=44)                      | 2023-06-03 | [Rust](project_euler/src/bin/problem44.rs)                           | 150 s.             |                   | An EXTREMELY slow solution, doing a brute force search (first over the difference, then over the smaller of the two pentagonal numbers).                                                                                                    |
|    |                                                                              | 2023-06-11 | [Rust](project_euler/src/bin/problem44_v2.rs)                        | 26 s.              |                   | Same algorithm, but using num crate's integer square root implementation instead of my own.                                                                                                                                                 |
| 45 | [Triangular, Pentagonal, and Hexagonal](https://projecteuler.net/problem=45) | 2023-07-08 | [Rust](project_euler/src/bin/problem45.rs)                           | 71 µs.             |                   | Three iterators were used, one for each value of n. The 3 iterators were moved ahead in unison to keep the 3 numbers (triangular, pentagonal and hexagonal) close together to find a match.                                                 |
|    |                                                                              | 2023-07-08 | [Rust](project_euler/src/bin/problem45_invert.rs)                    | 520 µs.            |                   | Iterate over hexagonal numbers, using a formula to invert the pentagonal and triangular numbers. Slightly more succinct, but much slower than the previous solution.                                                                        |
|    |                                                                              | 2023-07-08 | [Rust](project_euler/src/bin/problem45_fast.rs)                      | 42 µs.             |                   | The same as my first solution, but using the fact that H(n) = T(2n-1), so the triangular numbers don't need to be iterated over. I had missed this, but it was pointed out on the forum.                                                    |
| 46 | [Goldbach's Other Conjecture](https://projecteuler.net/problem=46)           | 2023-07-11 | [Rust](project_euler/src/bin/problem46.rs)                           | 2.69 ms.           |                   | Cache odd primes while finding odd composites. Iterate over cached primes to check the conjecture.                                                                                                                                          |
|    |                                                                              | 2023-07-11 | [Rust](project_euler/src/bin/problem46_v2.rs)                        | 1.81 ms.           |                   | As above, but with a high performance prime testing algorithm, only testing integers (beyond 3) of the form 6k +/- 1.                                                                                                                       |
|    |                                                                              | 2023-07-12 | [Rust](project_euler/src/bin/problem46_v3.rs)                        | 830 µs.            |                   | As above, but with a better is_square() algorithm, excluding numbers whose final digits in base 16 are 0, 1, 4 or 9. (Other bases were tried, but this performed best.)                                                                     |
|    |                                                                              | 2023-07-13 | [Rust](project_euler/src/bin/problem46_v4.rs)                        | 5.71 ms.           |                   | As above, but not caching primes, and instead checking primality on the fly while checking the conjecture. This was significantly slower.                                                                                                   |
|    |                                                                              | 2023-07-13 | [Rust](project_euler/src/bin/problem46_v5.rs)                        | 265 µs.            |                   | Iterate over squares of integers, checking for a number being prime while checking the conjecture. Instead of over primes and checking for a square. Not my idea: I saw this on the forum.                                                  |
| 47 | [Distinct Primes Factors](https://projecteuler.net/problem=47)               | 2023-07-16 | [Rust](project_euler/src/bin/problem47.rs)                           | 2.3 s.             |                   | Slow brute force approach. Update cache of primes when calculating only 1 divisor while iterating over integers and counting their unique prime factors.                                                                                    |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v2.rs)                        | 0.4 s.             |                   | Same algorithm. Improved speed by stopping iterating over primes when a number is fully factorized.                                                                                                                                         |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v3.rs)                        | 1.23 s.            |                   | Similar, but without caching primes. As with problem 46, this is slower than caching primes.                                                                                                                                                |
|    |                                                                              | 2023-07-16 | [Rust](project_euler/src/bin/problem47_v4.rs)                        | 212 ms.            |                   | Caching primes and cache unique prime factors, so that we only need to find the first prime that divides a number. NB: This was not my idea, but something I saw on the forum.                                                              |
| 48 | [Self Powers](https://projecteuler.net/problem=48)                           | 2023-07-24 | [Rust](project_euler/src/bin/problem48.rs)                           | 3.012 ms.          |                   |                                                                                                                                                                                                                                             |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem48_v2.rs)                        | 1.818 ms.          |                   | Simpler and faster.                                                                                                                                                                                                                         |
| 49 | [Prime Permutations](https://projecteuler.net/problem=49)                    | 2023-07-29 | [Rust](project_euler/src/bin/problem49_perm_codes.rs)                | 210 µs.            | 70 µs.            | Duration: 156 µs (to first solution). 210 µs (exhaustive search). Use a hash map to group prime candidates using a u32 hash key. Use 3 bits per digit to count the # of that digit.                                                         |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem49_v2_perm_codes.rs)             | 215 µs.            | 83 µs.            | Duration: 170 µs (to first solution). 215 µs (exhaustive search). The same approach but using 4 nested loops over possible digits of a prime number, instead of iterating over numbers of the form 6k +/- 1 and then calculating digits.    |
|    |                                                                              | 2023-07-30 | [Rust](project_euler/src/bin/problem49_v3_arithmetic_sequence.rs)    | 5.7 ms.            | 2.5 ms.           | Duration: 1.18 ms to first solution. 5.7 ms (exhaustive search). Generate all possible arithmetic sequences of three 4-digit numbers of the form 6n+/-1. Use the same hash code function to check if they are permutations of one another.  |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem49_v4_prime_sieve.rs)            | 535 µs.            | 253 µs.           | Duration: 270 µs (to first solution). 535 µs (exhaustive search). Use Eratosthenes sieve to get all 4 digit primes, but augment these with the same hash code function used previously (to check for permutations). Faster than expected.   |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem49_v5_primes.rs)                 | 525 µs.            | 618 µs.           | Duration: 281 µs (to first solution). 525 µs (exhaustive search). Like the previous method but check primes directly (checking smaller divisors) instead of using the sieve of Eratosthenes to get all 4 digit primes. Not the bottleneck!  |
|    |                                                                              | 2023-08-05 | [Rust](project_euler/src/bin/problem49_v6_digits.rs)                 | 2.59 ms.           | 455 µs.           | Duration: 2.26 ms (to first solution). 2.59 ms (exhaustive search). Given sequence a,b,c with d = b-a=c-b, use 8 loops over digits a0,d0,...,a3,d3. Prune the search by allowing at most 4 unique digits in a, b and c. Slow and ugly!      |
|    |                                                                              | 2023-08-06 | [Rust](project_euler/src/bin/problem49_v7_digits2.rs)                | 9.2 ms.            | 1.35 ms.          | Duration: 5.3 ms (to first solution). 9.2 ms (exhaustive search). Very similar to the previous solution. Logically, this *should* have made the code faster, since it's doing less. Instead it's worse! No point in further refactorings.   |
| 50 | [Consecutive Prime Sum](https://projecteuler.net/problem=50)                 | 2023-08-13 | [Rust](project_euler/src/bin/problem50.rs)                           | 3.8 s.             | 1.22 s.           |                                                                                                                                                                                                                                             |
|    |                                                                              | 2023-08-18 | [Rust](project_euler/src/bin/problem50_v2.rs)                        | 52.8 ms.           | 14.4 ms.          | MUCH faster! Search downwards by the number of terms in the solution, so that the first solution found will be optimal.                                                                                                                     |
|    |                                                                              | 2023-08-18 | [Rust](project_euler/src/bin/problem50_v3.rs)                        | 53 ms.             | 14.5 ms.          | Clean up previous solution by replacing vec of tuples with two vecs of integers: primes and cum_primes.                                                                                                                                     |
|    |                                                                              | 2023-08-18 | [Rust](project_euler/src/bin/problem50_v4.rs)                        | 54 ms.             | 14.4 ms.          | Clean up previous solution by having only one vector of primes, and calculating sums of primes on the fly. This is no faster because calculating the primes completely dominates the times.                                                 |
|    |                                                                              | 2023-08-18 | [Rust](project_euler/src/bin/problem50_v5.rs)                        | 42 µs.             | 6.7 µs.           | MUCH faster, but cheats! Use the second solution above, but once the cumulative sum exceeds 1 million, stop generating further primes. (Not my own idea: I saw this tip on the forum.) NB: Needs fixing to be rigorous!                     |
|    |                                                                              | 2023-09-02 | [Rust](project_euler/src/bin/problem50_v6.rs)                        | 44 µs.             | 7.1 µs.           | The previous solution made rigorous. Generate additional primes, so that the last T primes don't exceeed one million, where T is the number of terms in the initial best solution. Then solve again (which is very cheap).                  |
| 51 | [Prime Digit Replacements](https://projecteuler.net/problem=51)              | 2023-09-24 | [Rust](project_euler/src/bin/problem51.rs)                           | 29 ms.             | 6.4 ms.           | Recursively generate digits from most to least significant, and from 0 to 9. If digit is 0, 1 or 2, and a lowest digit for the mask isn't set, or matches the digit, also branch on the case where it is part of the mask.                  |
| 52 | [Permuted Multiples](https://projecteuler.net/problem=52)                    | 2024-09-13 | [Rust](project_euler/src/bin/problem52.rs)                           | 7.7 ms.            | 4.0 ms.           | Simple brute force approach. The answer is the first 6 decimal digits of 1/7, which is quite pretty, since those digits permute for different multiples of 1/7.                                                                             |
| 53 | [Combinatoric Selections](https://projecteuler.net/problem=53)               | 2024-11-03 | [Rust](project_euler/src/bin/problem53.rs)                           | 1.8 µs.            | 1.8 µs.           |                                                                                                                                                                                                                                             |
| 54 | [Poker Hands](https://projecteuler.net/problem=54)                           |            | [Rust](project_euler/src/bin/problem54.rs)                           | 657 µs.            | 134 µs.           |                                                                                                                                                                                                                                             |
| 55 | [Lychrel Numbers](https://projecteuler.net/problem=55)                       | 2024-11-09 | [Rust](project_euler/src/bin/problem55.rs)                           | 3.16 ms.           | 1.79 ms.          |                                                                                                                                                                                                                                             |
| 56 | [Powerful Digit Sum](https://projecteuler.net/problem=56)                    | 2025-06-11 | [Rust](project_euler/src/bin/problem56.rs)                           |                    | 1.16 ms.          |                                                                                                                                                                                                                                             |
| 57 | [Square Root Convergents](https://projecteuler.net/problem=57)               | 2025-06-12 | [Rust](project_euler/src/bin/problem57.rs)                           |                    | 390 µs.           | Tips: Calculate next fraction (n'/d') by substituting current fraction (n/d) into denominator of next expression to derive: n' = 2n + d, d' = n + d. gcd(n', d') = 1 if gcd(n, d) = 1. So, by induction, n'/d' is already in simplest form. |
| 58 | [Spiral Primes](https://projecteuler.net/problem=58)                         | 2025-06-13 | [Rust](project_euler/src/bin/problem58.rs)                           |                    | 14.3 ms.          |                                                                                                                                                                                                                                             |
| 59 | [XOR Decryption](https://projecteuler.net/problem=59)                        | 2025-06-13 | [Rust](project_euler/src/bin/problem59.rs)                           |                    | 40.7 ms.          | The duration includes the time to read the input file.                                                                                                                                                                                      |
| 60 | [Prime Pair Sets](https://projecteuler.net/problem=60)                       | 2025-06-20 | [Rust](project_euler/src/bin/problem60.rs)                           |                    | 2.778 s.          |                                                                                                                                                                                                                                             |
| 61 | [Cyclical Figurate Numbers](https://projecteuler.net/problem=61)             | 2025-06-28 | [Rust](project_euler/src/bin/problem61.rs)                           |                    | 1.06 ms.          | Solved for all solutions instead of stopping at the first one, since that makes performance comparable across different algorithms.                                                                                                         |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_v2.rs)                        |                    | 921 µs.           | 13% faster by using an array of small arrays instead of a vector of hash tables for mapping first 2 digits to last 2 digits per type of figurate number. Defined a new struct: InlineVec<T, const N: usize>) to wrap the small arrays.      |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_v3.rs)                        |                    | 101 µs.           | Over 9x faster by searching recursively for the cycle figurate numbers with the minimum sum, instead of building intermediate vectors of results.                                                                                           |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_find_first.rs)                |                    | 99 µs.            | This searches for the first answer, stopping as soon as one is found. This is only marginally faster than searching for all answers (of which there will only be 1), and choosing the minimum sum.                                          |
|    |                                                                              | 2025-06-29 | [Rust](project_euler/src/bin/problem61_v4.rs)                        |                    | 34 µs.            | 3x faster. Instead of pre-computing all permutations of the types of figurate numbers, generate these on the fly. This avoids repeatedly re-evaluating permutations that are identical up to the point at which they fail.                  |
|    |                                                                              | 2025-06-30 | [Rust](project_euler/src/bin/problem61_v5.rs)                        |                    | 24 µs.            | 29% faster. Start from octagonal numbers, not triangular, since there are fewer of them in the 4 digit range. So the recursive search tree will probably explore fewer branches.                                                            |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_v6.rs)                        |                    | 14 µs.            | A new approach: build a graph where nodes are pairs of digits and edges link to the next pair of edges to form a figurate number, "coloured" by the type of figurate number. Search the graph from each octagonal number in the range.      |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_v7.rs)                        |                    | 12 µs.            | Use bit masks instead of array of bools to track which figurate number types have already been used.                                                                                                                                        |
|    |                                                                              |            | [Rust](project_euler/src/bin/problem61_v8.rs)                        |                    | 48 µs.            | 4x slower using Rayon to parallelize the top level of the search. (Not very surprising, but it was still worth experimenting with.)                                                                                                         |
| 62 | [Cubic Permutations](https://projecteuler.net/problem=62)                    | 2025-07-01 | [Rust](project_euler/src/bin/problem62.rs)                           |                    | 309 µs.           |                                                                                                                                                                                                                                             |
| 63 | [Powerful Digit Counts](https://projecteuler.net/problem=63)                 | 2025-07-03 | [Rust](project_euler/src/bin/problem63.rs)                           |                    | 0.55 ns.          | Unbelievable... a trillion repetitions took just 0.55 seconds! What magic is enabling this? (Running on Godbolt.org, each repetition took 868 ns, which is not so surprising.)                                                              |
| 64 | [Odd Period Square Roots](https://projecteuler.net/problem=64)               | 2025-07-11 | [Rust](project_euler/src/bin/problem64.rs)                           |                    | 44.4 ms.          | A slow and ugly solution.                                                                                                                                                                                                                   |
|    |                                                                              | 2025-08-04 | [Rust](project_euler/src/bin/problem64_v2.rs)                        |                    | 1.66 ms.          | Using a formula from [Wikipedia](https://en.wikipedia.org/wiki/Periodic_continued_fraction#Canonical_form_and_repetend).                                                                                                                    |
| 65 | [Convergents of e](https://projecteuler.net/problem=65)                      | 2025-07-19 | [Rust](project_euler/src/bin/problem65.rs)                           |                    | 322 µs.           | Using num_bigint::BigInt instead of writing my own.                                                                                                                                                                                         |
|    |                                                                              | 2025-08-04 | [Rust](project_euler/src/bin/problem65_v2.rs)                        |                    | 9 µs.             | Using a formula from [Wikipedia](https://en.wikipedia.org/wiki/Simple_continued_fraction#Infinite_continued_fractions_and_convergents).                                                                                                     |
| 66 | [Diophantine Equation](https://projecteuler.net/problem=66)                  | 2025-07-29 | [Rust](project_euler/src/bin/problem66_stack_overflow.rs)            | N/A                | N/A               | Can only solve for D up to 60, then a stack overflow occurs. Keeps track of prime factorizations of x-1, x and x+1. It iterates over x, calculates the prime factorization of x^2-1, and recursively builds up and tests D values.          |
|    |                                                                              | 2025-08-04 | [Rust](project_euler/src/bin/problem66_v7_continued_fractions.rs)    |                    | 1.56 ms.          | Using the continued fractions algorithm for Pell's equation from [Wikipedia](https://en.wikipedia.org/wiki/Pell%27s_equation#Fundamental_solution_via_continued_fractions) and the formulae from problems 64 (v2) and 65 (v2).              |
| 67 | [Maximum Path Sum II](https://projecteuler.net/problem=67)                   | 2025-08-06 | [Rust](project_euler/src/bin/problem67.rs)                           |                    | 8.3 µs.           | The algorithm from problem 18 was fast enough to solve this problem as well!                                                                                                                                                                |
| 68 | [Magic 5-gon Ring](https://projecteuler.net/problem=68)                      | 2025-08-10 | [Rust](project_euler/src/bin/problem68.rs)                           |                    | 330 ns            | An extremely fast and flexible solution approach, defining a sequence of instructions, one per layer of the search tree. Quite verbose though.                                                                                              |
|    |                                                                              | 2025-08-11 | [Rust](project_euler/src/bin/problem68_v2.rs)                        |                    | 365 ns.           | Fixed a clippy suggestion (three functions took too many arguments), but it's slightly slower.                                                                                                                                              |
| 69 | [Totient Maximum](https://projecteuler.net/problem=69)                       | 2025-08-14 | [Rust](project_euler/src/bin/problem69.rs)                           |                    | 22 ns             | n/phi(n) = product of p/(p-1) where p is a prime that divides n. Count each prime only once. p/(p-1) is decreasing as p increases. So simply multiply the primes together until the next product would exceed a million.                    |

_Note: Timings based on an i7-6700 CPU and/or a MacBook Pro M4 Pro. Durations exclude I/O (reading the input file and writing the answer to the terminal) unless indicated._


## Advent of Code

### Learning by comparison

Many participants share their solutions on the reddit [AOC mega-thread](https://www.reddit.com/r/adventofcode/wiki/solution_megathreads).

This can be very useful for:
* Comparing solution approaches.
* Learning clever tricks and handy features of the language and libraries.
* Comparing readability of different coding styles and languages.
* Comparing performance of solutions.

### 2020

| Day                                          | Part | Date Solved | My solution                                           |
|----------------------------------------------|------|-------------|-------------------------------------------------------|
| [Day 1](https://adventofcode.com/2020/day/1) | 1    | 2021-11-18  | [Rust](AdventOfCode/Aoc2020/src/bin/day1_problem1.rs) | 
|                                              | 2    | 2021-11-18  | [Rust](AdventOfCode/Aoc2020/src/bin/day1_problem2.rs) |
| [Day 2](https://adventofcode.com/2020/day/2) | 1    | 2021-11-20  | [Rust](AdventOfCode/Aoc2020/src/bin/day2_problem1.rs) |
|                                              | 2    | 2021-11-20  | [Rust](AdventOfCode/Aoc2020/src/bin/day2_problem2.rs) |
| [Day 3](https://adventofcode.com/2020/day/3) | 1    | 2021-11-27  | [Rust](AdventOfCode/Aoc2020/src/bin/day3_problem1.rs) |
|                                              | 2    | 2021-11-27  | [Rust](AdventOfCode/Aoc2020/src/bin/day3_problem2.rs) |

### 2021

| Day                                        | Part  | Date Solved | My solution                                                     | Notes                                                                                                                                   |
|--------------------------------------------|-------|-------------|-----------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| [1](https://adventofcode.com/2021/day/1)   | 1     | 2021-12-01  | [Rust](AdventOfCode/aoc2021/src/bin/day1_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-01  | [Rust](AdventOfCode/aoc2021/src/bin/day1_problem2.rs)           |                                                                                                                                         |
| [2](https://adventofcode.com/2021/day/2)   | 1     | 2021-12-02  | [Rust](AdventOfCode/aoc2021/src/bin/day2_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-02  | [Rust](AdventOfCode/aoc2021/src/bin/day2_problem2.rs)           |                                                                                                                                         |
| [3](https://adventofcode.com/2021/day/3)   | 1     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day3_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day3_problem2.rs)           |                                                                                                                                         |
| [4](https://adventofcode.com/2021/day/4)   | 1     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day4_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-04  | [Rust](AdventOfCode/aoc2021/src/bin/day4_problem2.rs)           |                                                                                                                                         |
| [5](https://adventofcode.com/2021/day/5)   | 1     | 2021-12-05  | [Rust](AdventOfCode/aoc2021/src/bin/day5_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-05  | [Rust](AdventOfCode/aoc2021/src/bin/day5_problem2.rs)           |                                                                                                                                         |
| [6](https://adventofcode.com/2021/day/6)   | 1     | 2021-12-06  | [Rust](AdventOfCode/aoc2021/src/bin/day6_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-06  | [Rust](AdventOfCode/aoc2021/src/bin/day6_problem2.rs)           |                                                                                                                                         |
| [7](https://adventofcode.com/2021/day/7)   | 1     | 2021-12-07  | [Rust](AdventOfCode/aoc2021/src/bin/day7_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-07  | [Rust](AdventOfCode/aoc2021/src/bin/day7_problem2.rs)           |                                                                                                                                         |
| [8](https://adventofcode.com/2021/day/8)   | 1     | 2021-12-08  | [Rust](AdventOfCode/aoc2021/src/bin/day8_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-08  | [Rust](AdventOfCode/aoc2021/src/bin/day8_problem2.rs)           |                                                                                                                                         |
| [9](https://adventofcode.com/2021/day/9)   | 1     | 2021-12-09  | [Rust](AdventOfCode/aoc2021/src/bin/day9_problem1.rs)           |                                                                                                                                         |
|                                            | 2     | 2021-12-09  | [Rust](AdventOfCode/aoc2021/src/bin/day9_problem2.rs)           |                                                                                                                                         |
| [10](https://adventofcode.com/2021/day/10) | 1     | 2021-12-10  | [Rust](AdventOfCode/aoc2021/src/bin/day10_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2021-12-10  | [Rust](AdventOfCode/aoc2021/src/bin/day10_problem2.rs)          |                                                                                                                                         |
| [11](https://adventofcode.com/2021/day/11) | 1 & 2 | 2021-12-11  | [Rust](AdventOfCode/aoc2021/src/bin/day11_problem1and2.rs)      |                                                                                                                                         |
| [12](https://adventofcode.com/2021/day/12) | 1     | 2021-12-12  | [Rust](AdventOfCode/aoc2021/src/bin/day12_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2021-12-12  | [Rust](AdventOfCode/aoc2021/src/bin/day12_problem2.rs)          |                                                                                                                                         |
| [13](https://adventofcode.com/2021/day/13) | 1     | 2021-12-13  | [Rust](AdventOfCode/aoc2021/src/bin/day13_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2021-12-13  | [Rust](AdventOfCode/aoc2021/src/bin/day13_problem2.rs)          |                                                                                                                                         |
| [14](https://adventofcode.com/2021/day/14) | 1     | 2021-12-14  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2021-12-14  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt1.rs) | Attempt 1: Would probably take 20.5 hours to run.                                                                                       |
|                                            | 2     | 2021-12-15  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt2.rs) | Attempt 2: 205ms using nalgebra 0.30 crate with f64 matrix elements.                                                                    |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt3.rs) | Attempt 3: 3.37s. Handwritten linear algebra. Messy. My Rust skills aren't good enough for this yet!                                    |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt4.rs) | Attempt 4: 82µs!                                                                                                                        |
|                                            | 2     | 2021-12-18  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt5.rs) | Attempt 5: 446µs. Like attempt 4, but using BTreeMap instead of arrays, due to sparsity, but it was slower.                             |
|                                            | 2     | 2022-01-02  | [Rust](AdventOfCode/aoc2021/src/bin/day14_problem2_attempt6.rs) | Attempt 6: 1.25s using nalgebra 0.30 crate with usize matrix elements. Much slower, unfortunately.                                      |
| [15](https://adventofcode.com/2021/day/15) | 1     | 2021-12-20  | [Rust](AdventOfCode/aoc2021/src/bin/day15_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2021-12-20  | [Rust](AdventOfCode/aoc2021/src/bin/day15_problem2.rs)          |                                                                                                                                         |
| [16](https://adventofcode.com/2021/day/16) | 1     | 2021-12-23  | [Rust](AdventOfCode/aoc2021/src/bin/day16_problem1.rs)          | Feels quite elegant (albeit verbose, and without enough checking for invalid parse formats).                                            |
|                                            | 2     | 2021-12-23  | [Rust](AdventOfCode/aoc2021/src/bin/day16_problem2.rs)          | Part 2 easily accommodated. 544 LOC exactly evenly split between 272 lines of code and 272 of unit tests.                               |
| [17](https://adventofcode.com/2021/day/17) | 1     | 2022-01-15  | [Rust](AdventOfCode/aoc2021/src/bin/day17_problem1.rs)          | Use triangular numbers for bounds of velocities. Then use brute force simulation (avoiding tricky math).                                |
|                                            | 2     | 2022-01-15  | [Rust](AdventOfCode/aoc2021/src/bin/day17_problem2.rs)          |                                                                                                                                         |
| [18](https://adventofcode.com/2021/day/18) | 1 & 2 | 2022-03-06  | [Rust](AdventOfCode/aoc2021/src/bin/day18_problem1and2.rs)      |                                                                                                                                         |
| [19](https://adventofcode.com/2021/day/19) | 1 & 2 | 2022-09-21  | [Rust](AdventOfCode/aoc2021/src/bin/day19_problem1and2.rs)      | I was not looking forward to this one! Solved in 2.9 seconds using a brute force search.                                                |
| [20](https://adventofcode.com/2021/day/20) | 1 & 2 | 2022-10-03  | [Rust](AdventOfCode/aoc2021/src/bin/day20_problem1and2.rs)      | Built first time. Only 1 bug (reversed order of bits in 9 bit input). Part 1 took 172µs. Part 2 took 6.8ms.                             |
| [21](https://adventofcode.com/2021/day/21) | 1     | 2022-10-04  | [Rust](AdventOfCode/aoc2021/src/bin/day21_problem1.rs)          |                                                                                                                                         |
|                                            | 2     | 2022-10-05  | [Rust](AdventOfCode/aoc2021/src/bin/day21_problem2.rs)          | Duration: 350µs.                                                                                                                        |
| [22](https://adventofcode.com/2021/day/22) | 1 & 2 | 2022-10-09  | [Rust](AdventOfCode/aoc2021/src/bin/day22_problem1and2.rs)      | Part 1 duration: 831ms. Part 1 and 2 combined duration: 1.46s.                                                                          |
| [23](https://adventofcode.com/2021/day/23) | 1     | 2024-01-21  | [Rust](AdventOfCode/aoc2021/src/bin/day23_problem1.rs)          | Part 1 duration: 792µs. Hard! Calculated a matrix of distances and paths with petgraph. Used A* and a compact u32 state representation. |

### 2022

| Day | Description                                                    | Part  | Date       | Solution                                                                 | Notes                                           |
|-----|----------------------------------------------------------------|-------|------------|--------------------------------------------------------------------------|-------------------------------------------------|
| 1   | [Calorie Counting](https://adventofcode.com/2022/day/1)        | 1     | 2022-12-01 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day1_part1.py)          |                                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part1.rs)                       |                                                 |
|     |                                                                | 2     | 2022-12-01 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day1_part2.py)          |                                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part2.rs)                       | Duration: 107µs                                 |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day1_part2_fast.rs)                  | Duration: 98µs                                  |
| 2   | [Rock Paper Scissors](https://adventofcode.com/2022/day/2)     | 1     | 2022-12-02 | [Rust](AdventOfCode/aoc2022/src/bin/day2_part1.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day2_part1.py)          | Succinct, but too much magic in formula!        |
|     |                                                                | 2     | 2022-12-02 | [Rust](AdventOfCode/aoc2022/src/bin/day2_part2.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day2_part2.py)          |                                                 |
| 3   | [Rucksack Reorganization](https://adventofcode.com/2022/day/3) | 1     | 2022-12-03 | [Rust](AdventOfCode/aoc2022/src/bin/day3_part1.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part1.py)          | Using list comprehensions                       |
|     |                                                                |       | 2022-12-04 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part1_for_loop.py) | Using for loop (longer, but more readable)      |
|     |                                                                | 2     | 2022-12-03 | [Rust](AdventOfCode/aoc2022/src/bin/day3_part2.rs)                       |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part2.py)          | Using list comprehensions                       |
|     |                                                                |       | 2022-12-04 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day3_part2_for_loop.py) | Using for loop (longer, but more readable)      |
| 4   | [Camp Cleanup](https://adventofcode.com/2022/day/4)            | 1 & 2 | 2022-12-04 | [Rust](AdventOfCode/aoc2022/src/bin/day4_part1and2.rs)                   |                                                 |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day4_part1and2.py)      |                                                 |
| 5   | [Supply Stacks](https://adventofcode.com/2022/day/5)           | 1 & 2 | 2022-12-05 | [Rust](AdventOfCode/aoc2022/src/bin/day5_part1and2.rs)                   |                                                 |
| 6   | [Tuning Trouble](https://adventofcode.com/2022/day/6)          | 1 & 2 | 2022-12-06 | [Rust](AdventOfCode/aoc2022/src/bin/day6_part1and2.rs)                   | Efficient. 43 LOC.                              |
|     |                                                                |       |            | [Rust](AdventOfCode/aoc2022/src/bin/day6_part1and2_windows.rs)           | 23 LOC (excluding unit tests). Over 10x slower. |
|     |                                                                |       |            | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day6_part1and2.py)      | Succinct. 9 LOC.                                |
| 7   | [No Space Left On Device](https://adventofcode.com/2022/day/7) | 1 & 2 | 2023-04-23 | [Rust](AdventOfCode/aoc2022/src/bin/day7.rs)                             | Verbose.                                        |
|     |                                                                |       | 2023-05-08 | [Python](AdventOfCode/aoc2022/src/python/aoc2022_day7_part1and2.py)      |                                                 |
| 8   | [Treetop Tree House](https://adventofcode.com/2022/day/8)      | 1 & 2 |            | [Rust](AdventOfCode/aoc2022/src/bin/day8.rs)                             |                                                 |
| 9   | [Rope Bridge](https://adventofcode.com/2022/day/9)             | 1     | 2023-05-13 | [Rust](AdventOfCode/aoc2022/src/bin/day9_part1.rs)                       |                                                 |
|     |                                                                | 2     | 2023-05-14 | [Rust](AdventOfCode/aoc2022/src/bin/day9_part2.rs)                       | Duration: 655µs (excl. I/O).                    |
| 10  | [Cathode-Ray Tube](https://adventofcode.com/2022/day/10)       | 1     | 2023-10-22 | [Rust](AdventOfCode/aoc2022/src/bin/day10_part1.rs)                      |                                                 |
|     |                                                                | 2     | 2023-10-22 | [Rust](AdventOfCode/aoc2022/src/bin/day10_part2.rs)                      |                                                 |

### 2023

Rust utility methods can be found in [lib.rs](AdventOfCode/aoc2023/src/lib.rs).
These can be used to easily calculate the average duration of solution algorithms over many repetitions.

| Day | Description                                                            | Part | Date       | Solution                                                        | Duration | Notes                                                                                     |
|-----|------------------------------------------------------------------------|------|------------|-----------------------------------------------------------------|----------|-------------------------------------------------------------------------------------------|
| 1   | [Trebuchet?!](https://adventofcode.com/2023/day/1)                     | 1    | 2023-12-01 | [Rust](AdventOfCode/aoc2023/src/bin/day1_part1.rs)              | 72µs     |                                                                                           |
|     |                                                                        | 2    | 2023-12-01 | [Rust](AdventOfCode/aoc2023/src/bin/day1_part2.rs)              | 213µs    | Define an iterator over digits in a &str                                                  |
|     |                                                                        |      |            | [Rust](AdventOfCode/aoc2023/src/bin/day1_part2_simple.rs)       | 247µs    | Shorter and simpler approach                                                              |
|     |                                                                        |      | 2023-12-02 | [Rust](AdventOfCode/aoc2023/src/bin/day1_part2_fast.rs)         | 175µs    | Faster but more verbose. Uses bytes not chars. Searches backwards to find the last digit. |
| 2   | [Cube Conundrum](https://adventofcode.com/2023/day/2)                  | 1    | 2023-12-02 | [Rust](AdventOfCode/aoc2023/src/bin/day2_part1.rs)              | 55µs     |                                                                                           |
|     |                                                                        | 2    | 2023-12-02 | [Rust](AdventOfCode/aoc2023/src/bin/day2_part2.rs)              | 111µs    |                                                                                           |
| 3   | [Gear Ratios](https://adventofcode.com/2023/day/3)                     | 1    | 2023-12-04 | [Rust](AdventOfCode/aoc2023/src/bin/day3_part1.rs)              | 143µs    |                                                                                           |
|     |                                                                        | 2    | 2023-12-04 | [Rust](AdventOfCode/aoc2023/src/bin/day3_part2.rs)              | 115µs    |                                                                                           |
| 4   | [Scratchcards](https://adventofcode.com/2023/day/4)                    | 1    | 2023-12-04 | [Rust](AdventOfCode/aoc2023/src/bin/day4_part1.rs)              | 345µs    |                                                                                           |
|     |                                                                        | 2    | 2023-12-04 | [Rust](AdventOfCode/aoc2023/src/bin/day4_part2.rs)              | 303µs    |                                                                                           |
| 5   | [If You Give A Seed A Fertilizer](https://adventofcode.com/2023/day/5) | 1    | 2023-12-05 | [Rust](AdventOfCode/aoc2023/src/bin/day5_part1and2.rs)          | 75µs     |                                                                                           |
|     |                                                                        | 2    | 2023-12-06 | Shared with part 1                                              | 131s     | Processing 1,246,535,481 seeds one at a time is slow!                                     |
| 6   | [Wait For It](https://adventofcode.com/2023/day/6)                     | 1    | 2023-12-07 | [Rust](AdventOfCode/aoc2023/src/bin/day6_part1and2.rs)          | 440ns    |                                                                                           |
|     |                                                                        | 2    |            | Shared with part 1                                              | 1.583µs  |                                                                                           |
| 7   | [Camel Cards](https://adventofcode.com/2023/day/7)                     | 1    | 2023-12-08 | [Rust](AdventOfCode/aoc2023/src/bin/day7_part1and2.rs)          | 164µs    |                                                                                           |
|     |                                                                        | 2    |            | Shared with part 1                                              | 170µs    |                                                                                           |
| 8   | [Haunted Wasteland](https://adventofcode.com/2023/day/8)               | 1    | 2023-12-09 | [Rust](AdventOfCode/aoc2023/src/bin/day8_part1.rs)              | 144µs    | Pre-processing data takes 75µs. The calculation loop takes 69µs... under 3 ns per step!   |
|     |                                                                        |      | 2023-12-10 | [Rust](AdventOfCode/aoc2023/src/bin/day8_part1_large_lookup.rs) | 630µs   | Use a lookup table indexed by both an instruction and node index - 12 to 13ns per step.   |

_Note: Timings based on an i7-6700 CPU. Durations exclude I/O (reading the input file and writing the answer to the terminal) unless indicated._

### 2024

Rust utility methods can be found in [lib.rs](AdventOfCode/aoc2024_rs/src/lib.rs).
These can be used to easily calculate the average duration of solution algorithms over many repetitions.

| Day | Description                                                    | Part | Date       | Solution                                                               | Duration (i7-6700) | Duration (M4 Pro) | Notes                                                                                              |
|-----|----------------------------------------------------------------|------|------------|------------------------------------------------------------------------|--------------------|-------------------|----------------------------------------------------------------------------------------------------|
| 1   | [Historian Hysteria](https://adventofcode.com/2024/day/1)      | 1    | 2024-12-01 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day1_part1.rs)                  | 191 µs             | 39 µs             |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day1_part2.rs)                  | 174 µs             | 59 µs             |                                                                                                    |                                                                                                  |
| 2   | [Red-Nosed Reports](https://adventofcode.com/2024/day/2)       | 1    | 2024-12-02 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day2_part1.rs)                  | 419 µs             | 111 µs            |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day2_part2.rs)                  | 433 µs             | 102 µs            | Iterated windows of 3 levels at a time, considering dampening the last level of each such triple.  |
| 3   | [Mull It Over](https://adventofcode.com/2024/day/3)            | 1    | 2024-12-03 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day3_part1.rs)                  | 834 µs             |                   | Used regex                                                                                         |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day3_part2.rs)                  | 1.13 ms            |                   |                                                                                                    |
| 4   | [Ceres Search](https://adventofcode.com/2024/day/4)            | 1    | 2024-12-05 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day4_part1.rs)                  | 332 µs             |                   |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day4_part2.rs)                  | 136 µs             |                   | Part 2 was easier than part 1!                                                                     |
| 5   | [Print Queue](https://adventofcode.com/2024/day/5)             | 1    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day5_part1.rs)                  | 783 µs             |                   |                                                                                                    |
|     |                                                                | 2    | 2024-12-07 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day5_part2.rs)                  | 5.1 ms             |                   | Using a topological sort                                                                           |
|     |                                                                |      |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day5_part2_in_place_sorting.rs) | 969 µs             |                   | With in-place sorting: much faster!                                                                |
| 6   | [Guard Gallivant](https://adventofcode.com/2024/day/6)         | 1    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day6_part1.rs)                  | 88 µs              |                   |                                                                                                    |
|     |                                                                | 2    | 2024-12-09 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day6_part2.rs)                  | 182 ms             |                   |                                                                                                    |
| 7   | [Bridge Repair](https://adventofcode.com/2024/day/7)           | 1    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day7_part1.rs)                  | 1.7 ms             |                   |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day7_part2.rs)                  | 52 ms              |                   |                                                                                                    |
| 8   | [Resonant Collinearity](https://adventofcode.com/2024/day/8)   | 1    | 2024-12-14 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day8_part1.rs)                  | 66 µs              |                   |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day8_part2.rs)                  | 158 µs             |                   |                                                                                                    |
| 9   | [Disk Fragmenter](https://adventofcode.com/2024/day/9)         | 1    | 2024-12-15 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day9_part1.rs)                  | 677 µs             |                   |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day9_part2.rs)                  | 176 ms             |                   | A very slow solution!                                                                              |
| 10  | [Hoof It](https://adventofcode.com/2024/day/10)                | 1    | 2024-12-17 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day10_part1.rs)                 | 697 µs             |                   |                                                                                                    |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day10_part2.rs)                 | 102 ms             |                   | Part 2 was easier than part 1!                                                                     |
| 11  | [Plutonian Pebbles](https://adventofcode.com/2024/day/11)      | 1    | 2025-01-05 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day11_part1.rs)                 |                    | 1.003 ms          |                                                                                                    |
|     |                                                                | 2    | 2025-01-12 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day11_part2.rs)                 |                    | 937 µs            | Using dynamic programming (memoization) it's faster than part 1. So part 1 could be faster also.   |
| 12  | [Garden Groups](https://adventofcode.com/2024/day/12)          | 1    | 2025-02-06 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day12_part1.rs)                 |                    | 175 µs            |                                                                                                    |
|     |                                                                | 2    | 2025-02-22 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day12_part2.rs)                 |                    | 278 µs            | Quite verbose.                                                                                     |
| 13  | [Claw Contraption](https://adventofcode.com/2024/day/13)       | 1    | 2025-02-26 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day13_part1.rs)                 |                    | 43 µs             | Use linear algebra to invert a 2x2 matrix                                                          |
|     |                                                                | 2    |            | [Rust](AdventOfCode/aoc2024_rs/src/bin/day13_part2.rs)                 |                    | 44 µs             | Essentially the same solution as part 1                                                            |
| 14  | [Restroom Redoubt](https://adventofcode.com/2024/day/14)       | 1    | 2025-02-27 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day14_part1.rs)                 |                    | 22 µs             |                                                                                                    |
|     |                                                                | 2    | 2025-03-02 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day14_part2.rs)                 |                    |                   | Wrote a terminal app (using ratatui) to step through MANY iterations until seeing the easter egg!  |
| 15  | [Warehouse Woes](https://adventofcode.com/2024/day/15)         | 1    | 2025-03-06 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day15_part1.rs)                 |                    | 1.626 ms          |                                                                                                    |
|     |                                                                | 2    | 2025-03-12 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day15_part2.rs)                 |                    | 2.690 ms          |                                                                                                    |
| 16  | [Reindeer Maze](https://adventofcode.com/2024/day/16)          | 1    | 2025-03-29 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day16_part1.rs)                 |                    | 969 µs            | Hand-coded A* search. Moves are one turn left or right then add a move for each empty space ahead. |
|     |                                                                | 1    | 2025-04-03 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day16_part1_one_step.rs)        |                    | 1.16 ms           | Slower but simpler alternative for part 1. Move 1 step left, right or forward each turn.           |
|     |                                                                | 2    | 2025-04-01 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day16_part2.rs)                 |                    | 1.18 ms           | Using the slower approach of moving 1 step left, right or forward.                                 |
| 17  | [Chronospatial Computer](https://adventofcode.com/2024/day/17) | 1    | 2025-04-08 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day17_part1.rs)                 |                    | 486 ns            | Very simple.                                                                                       |
|     |                                                                | 2    | 2025-04-11 | [Rust](AdventOfCode/aoc2024_rs/src/bin/day17_part2_brute_force.rs)     |                    | Times out         | Perf optimizations unlikely to be enough as the answer will have 46 to 48 bits, i.e. > 64 x 10^12. |

_Note: Timings based on an i7-6700 CPU and/or a MacBook Pro M4 Pro. Durations exclude I/O (reading the input file and writing the answer to the terminal) unless indicated._


## cryptopals cryptography challenges

### Solutions for [Set 1](https://cryptopals.com/sets/1)

| Challenge | Description                                                               | Date Solved | Solution                                                  | Notes                                                                                                                                                                      |
|-----------|---------------------------------------------------------------------------|-------------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| #1        | [Convert hex to base64](https://cryptopals.com/sets/1/challenges/1)       | 2021-11-20  | [Rust](cryptopals/src/bin/challenge1.rs)             |                                                                                                                                                                                 |
| #2        | [Fixed XOR](https://cryptopals.com/sets/1/challenges/2)                   | 2021-12-01  | [Rust](cryptopals/src/bin/challenge2.rs)             |                                                                                                                                                                                 |
| #3        | [Single-byte XOR cipher](https://cryptopals.com/sets/1/challenges/3)      | 2021-12-03  | [Rust](cryptopals/src/bin/challenge3.rs)             | Order histogram of chars and find min variance of positions from frequency histogram.                                                                                           |
|           |                                                                           | 2022-01-15  | [Rust](cryptopals/src/bin/challenge3_alpha_count.rs) | Count lowercase ASCII letters twice, and uppercase once and use the key with the max score.                                                                                     |
| #4        | [Detect single-character XOR](https://cryptopals.com/sets/1/challenges/4) | 2022-01-15  | [Rust](cryptopals/src/bin/challenge4.rs)             | Naive ASCII score fails. More complex ascii score works, taking 15 ms. Letter frequency histogram approach takes 131 ms.                                                        |
| #5        | [Implement repeating-key XOR](https://cryptopals.com/sets/1/challenges/5) | 2022-05-29  | [Rust](cryptopals/src/bin/challenge5.rs)             | The repeating key XOR encryption function was added to lib.rs.                                                                                                                  |
| #6        | [Break repeating-key XOR](https://cryptopals.com/sets/1/challenges/6)     | 2022-06-28  | [Rust](cryptopals/src/bin/challenge6.rs)             | lib.rs was broken into various sub-modules including [base64](cryptopals/src/base64.rs) and [cipher::repeating_key_xor](cryptopals/src/ciphers/repeating_key_xor.rs) utilities. |
| #7        | [AES in ECB mode](https://cryptopals.com/sets/1/challenges/7)             | 2022-07-01  | [Rust](cryptopals/src/bin/challenge7.rs)             | [ciphers::aes](cryptopals/src/ciphers/aes.rs) wraps the call to the rust [openssl crate](https://crates.io/crates/openssl).                                                     |
| #8        | [Detect AES in ECB mode](https://cryptopals.com/sets/1/challenges/8)      | 2022-07-03  | [Rust](cryptopals/src/bin/challenge8.rs)             |                                                                                                                                                                                 |

## CSES Problem Set

### Introductory Problems

| # | Description                                              | Date       | Solution                                      | Notes                                                      |
|---|----------------------------------------------------------|------------|-----------------------------------------------|------------------------------------------------------------|
| 1 | [Weird Algorithm](https://cses.fi/problemset/task/1068)  | 2022-05-28 | [Rust](cses_rust/src/bin/weird_algorithm.rs)  |                                                            |
| 2 | [Missing Number](https://cses.fi/problemset/task/1083/)  | 2022-05-28 | [Rust](cses_rust/src/bin/missing_number.rs)   |                                                            |
| 3 | [Repetitions](https://cses.fi/problemset/task/1069)      | 2022-05-29 | [Rust](cses_rust/src/bin/repetitions.rs)      |                                                            |
| 4 | [Increasing Array](https://cses.fi/problemset/task/1094) | 2022-06-04 | [Rust](cses_rust/src/bin/increasing_array.rs) |                                                            |
| 5 | [Permutations](https://cses.fi/problemset/task/1070/)    | 2022-06-05 | [Rust](cses_rust/src/bin/permutations.rs)     |                                                            |
| 6 | [Number Spiral](https://cses.fi/problemset/task/1071/)   | 2022-06-29 | [Rust](cses_rust/src/bin/number_spiral.rs)    |                                                            |
| 7 | [Two Knights](https://cses.fi/problemset/task/1072/)     | 2022-08-09 | [Rust](cses_rust/src/bin/two_knights.rs)      |                                                            |
| 8 | [Two Sets](https://cses.fi/problemset/task/1092/)        | 2022-08-21 | [Rust](cses_rust/src/bin/two_sets.rs)         | Elegant and obviously correct, but probably not efficient. |
|   |                                                          | 2022-08-21 | [Rust](cses_rust/src/bin/two_sets_v2.rs)      | Clever and efficient, but not obvious.                     |
| 9 | [Bit Strings](https://cses.fi/problemset/task/1617/)     | 2023-05-17 | [Rust](cses_rust/src/bin/bit_strings.rs)      | A simple, brute force approach, but fast enough.           |

## Katas from CodingDojo.org

| Exercise                                                     | Description                                    | Date       | Solution                                                                                                                               | Notes                                                                                                                           |
|--------------------------------------------------------------|------------------------------------------------|------------|----------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
| [Bowling scorer](https://codingdojo.org/kata/Bowling/)       | Ten pin bowling scoring algorithm              | 2015-09-25 | [readme](Katas/CodingDojo/Bowling/readme.md)                                                                                           | Requirements, design discussion and comparison of all solutions.                                                                |
|                                                              |                                                | 2015-09-25 | [C# (v1 - "monolithic" method)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer.cs)          |                                                                                                                                 |
|                                                              |                                                | 2015-09-25 | [C# (v2 - stateless)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer2.cs)                   |                                                                                                                                 |
|                                                              |                                                | 2015-09-27 | [C# (v3 - immutable)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/BowlingScorer3.cs)                   |                                                                                                                                 |
|                                                              |                                                | 2015-09-27 | [F# (pattern matching)](Katas/CodingDojo/Bowling/DotNet/src/main/fsharp/AndrewTweddle.Katas.Bowling.FSharp/FunctionalBowlingScorer.fs) |                                                                                                                                 |
|                                                              |                                                | 2015-09-25 | [unit tests](Katas/CodingDojo/Bowling/DotNet/src/test/csharp/AndrewTweddle.Katas.Test.Bowling)                                         |                                                                                                                                 |
|                                                              |                                                | 2022-10-27 | [Rust (pattern matching)](Katas/CodingDojo/Bowling/rust_bowl)                                                                          | Project directory for a typed and validated bowling scorer in Rust. It's verbose but checks many extra corner cases.            |
|                                                              |                                                |            | [lib.rs](Katas/CodingDojo/Bowling/rust_bowl/src/lib.rs)                                                                                | Shared types, utility functions and an error enum. The [thiserror](https://github.com/dtolnay/thiserror) crate is used.         |
|                                                              |                                                |            | [pattern_scorer.rs](Katas/CodingDojo/Bowling/rust_bowl/src/pattern_scorer.rs)                                                          | Use pattern matching over array slices of `Throw`'s to calculate the score (similar to the F# solution). Unit tests inline.     |
|                                                              |                                                | 2023-12-22 | [c_api.rs](Katas/CodingDojo/Bowling/rust_bowl/src/c_api.rs)                                                                            | Exposes a C API (FFI) so that the shared C# unit tests can also be used to test the Rust algorithm.                             |
|                                                              |                                                |            | [C# wrapper around Rust scorer](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/RustBowlingScorer.cs)      | Wraps the Rust C API call in a class that implements IBowlingScorer.                                                            |
|                                                              |                                                | 2023-12-17 | [C# (v4 - pattern scorer)](Katas/CodingDojo/Bowling/DotNet/src/main/csharp/AndrewTweddle.Katas.Bowling/PatternBowlingScorer.cs)        | Use pattern matching over Span<char> (char slices), similar to the F# and Rust solutions. (Depends on C# 11 language features.) |
| [Roman Numerals](https://codingdojo.org/kata/RomanNumerals/) | Convert to and from Roman numerals up to 3000. | 2021-06-01 | [README file](Katas/CodingDojo/RomanNumerals/README.md)                                                                                | This discusses the various experiments below.                                                                                   |
|                                                              |                                                | 2021-05-11 | [Rust (TDD)](Katas/CodingDojo/roman_numerals/src/main.rs)                                                                              | Experiment with TDD and with quickcheck property-based testing.                                                                 |
|                                                              |                                                | 2021-05-24 | [Rust v2](Katas/CodingDojo/RomanNumerals/Rust/roman_numerals_v2/src/main.rs)                                                           | Designed intuitively, not iteratively to compare with the TDD approach. Experiment with proptest property-based testing.        |
|                                                              |                                                | 2021-06-02 | [Rust v3](Katas/CodingDojo/RomanNumerals/Rust/roman_numerals_v3/src/main.rs)                                                           | A simpler approach (unfortunately not mine - I saw others doing this, and rewrote it in Rust).                                  |

## Miscellaneous

| Exercise                                                                  | Description                                                     | Date       | Solution                                                                                                           |
|---------------------------------------------------------------------------|-----------------------------------------------------------------|------------|--------------------------------------------------------------------------------------------------------------------|
| [wordrect](misc/WordRectangles) - [readme](misc/WordRectangles/readme.md) | Largest rectangle of letters with words in every row and column | 2020-01-19 | [Scala prototype (v1)](misc/WordRectangles/Scala_v1/src/main/scala/com/andrewtweddle/wordrects/WordRectMain.scala) |
|                                                                           |                                                                 | 2020-01-25 | [C++ prototype (v1)](misc/WordRectangles/Cpp_v1/main.cpp)                                                          | 

## CTCI

The CTCI sub-folder contains my solutions to exercises from the 5th edition of [Cracking the Coding Interview](http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X) by Gayle Laakmann McDowell.

| Exercise | Description                                               | My solutions                                                                                                                                       |
|----------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 1.1      | Check for duplicate letters in a string                   | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise1/DuplicateLetterChecker.cs)                                                  |
| 1.3      | Check if two strings are permutations                     | [C# (readable)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise3/SimplePermutationChecker.cs)                                     |
|          |                                                           | [C# (fast)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter1/Exercise3/QuickPermutationChecker.cs)                                          |
| 2.1      | Remove duplicate letters from a linked list               | [C# (fast)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise1/QuickDuplicateLetterRemover.cs)                                      |
|          |                                                           | [C# (without temporary buffer)](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise1/DuplicateLetterRemoverWithoutTemporaryBuffer.cs) |
| 3.1      | Implement multiple stacks in a single array               | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter3/Exercise1/StackArray.cs)                                                              |
| 3.1      | Repeat as a challenge, using array space more effectively | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter3/Exercise1Challenge/Stacker.cs)                                                        |
| 4.1      | Determine if a binary tree is balanced                    | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter4/Exercise1/BinaryTreeBalanceChecker.cs)                                                |
| 5.1      | Overwrite bits in one int from another                    | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter5/Exercise1/BitInserter.cs)                                                             |
| 9.1      | Number of different ways of hopping up stairs             | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter9/Exercise1/StepsSolver.cs)                                                             |
| 1.4      | Replacing spaces with "%20" in a string                   | [Scala](CTCI/Scala/src/main/scala/ctci/chapter1/Exercise4.scala)                                                                                   |
| 2.2      | kth to last node in a linked list                         | [C#](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI/Chapter2/Exercise2/Node.cs)                                                                    |

## Functional Programming In Scala

Exercises from the book
["Functional Programming in Scala"](http://www.manning.com/bjarnason/)
are in [a separate GitHub project](https://github.com/AndrewTweddle/fpinscala)
which was forked from [the original FPInScala repo](https://github.com/fpinscala/fpinscala)
for the book.

# Learnings and notes

## General approach

_Note: This is the approach I was experimenting with in 2015. It can be quite onerous and slow (compared to a more intuitive approach)._

### Follow a miniaturised SDLC

* Analysis
  * Summarize the problem statement (preferably highlighting critical clauses)
  * Confirm the scope
  * Question the requirements
  * Look for simplifying assumptions
  * List any issues that complicate things (and consider unit testing these earlier)
* Design
  * Brainstorm a number of solutions
    * Count number of steps and estimate the big-O scalability of each
    * Decide which solution to implement
      * Check the stakeholder's preferences when there is a trade-off (e.g. speed versus maintainability)
      * Otherwise, favour clarity over cleverness
    * Look for utility methods which could be useful across multiple solutions
  * Do UML designs if necessary
  * Do pseudocode if useful
    * Be alert for useful utility methods to make the main algorithm more readable
* Code
  * If there are multiple algorithms to implement, create a base class and a derived class per algorithm
* Unit test
  * If there are multiple algorithms to test, create a base class and a derived unit test class per implementation
* Code review
  * Look at the code critically
  * Refactor, add TODO's or make a note of areas that could be improved
* Compare
  * If a commonly used Kata (e.g. the bowling game), see how others have solved it and compare to my solution

### Use a notebook to write all code on paper first

* Ideally I wanted to use my whiteboard for all steps in this mini SDLC, but it was already in use
* Instead, I used a notebook to do analysis, design, coding and unit testing
* Once done I would capture and compile the code and unit tests electronically
  * An exception was exercise 4.1, which I coded directly.
  * The quality of the code in this exercise is noticeably worse, so pre-planning on paper is clearly worthwhile
  * I was initially skeptical of doing whiteboard coding in interviews, as this is not common practice in South Africa
  * However, I am already seeing benefits from doing this:
    * Improved designs through adding greater structure and focus to the creative process
    * An improved ability to "play out" detailed coding scenarios in my head
* I then fixed coding errors or refactored the code and made notes on these errors and refactorings
* After each exercise I add any language-specific notes and reminders to the sections below

  
## C\# 

| Purpose                       | Solution                                                                 | Notes                                                                                                                                                       |
|-------------------------------|--------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Sets                          | HashSet&lt;T&gt;                                                         | Useful methods: Add and Contains.                                                                                                                           |
| Hash maps                     | Dictionary&lt;K, V&gt;                                                   | Useful methods: ContainsKey, Keys, Values, enumerator over KeyValuePair&lt;K, V&gt;                                                                         |
| Test multiple implementations | MSTest: [TestMethod] on base class methods, [TestClass] on derived class | The derived unit test class chooses which implementation to use. The base class defines the common tests.                                                   |
| Assert.AreEqual               | Parameters: expected then actual                                         |                                                                                                                                                             |
| Int to binary string          | Convert.ToString(value, 2 )                                              | Useful for making unit test more readable. See [exercise 5.1](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI.Tests/Chapter5/Exercise1/WhenInsertingBits.cs) |
| Binary string to int          | Convert.ToInt32(str, 2 )                                                 | The second parameter is the base. See [exercise 5.1](CTCI/CSharp/AndrewTweddle.CodingExercises.CTCI.Tests/Chapter5/Exercise1/WhenInsertingBits.cs)          |
| Validate arguments            | ArgumentException(message, paramName )                                   | The parameter name is the second parameter to the constructor.                                                                                              |
| Validate argument range       | ArgumentOutOfRangeException(paramName, message)                          | But this time the parameter name is the first parameter to the constructor!                                                                                 |
| Overflow checking             | checked { ... }                                                          | Arithmetic overflow is silent unless the statement/s (NOT expressions) are in a checked block                                                               |
| Initialize dictionary         | ... = { {key; value}, ... }                                              |                                                                                                                                                             |

## Other coding tips

1. Whenever adding to an int, consider whether the expression should be in a checked block "{}" to catch overflows.
2. "for (int i = 0; i <= n; i++)" - consider whether n could be int.MaxValue, which would cause overflow. If so, consider summing in reverse.

## General approach

1. When faced with a "monolithic method", consider applying separation of concerns, even if this causes some duplication or multiple passes through a (small) iteration.
2. In the above case, consider refactoring out smaller methods first, as this might reduce duplication.
